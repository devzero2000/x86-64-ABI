
\chapter{Object Files}

\section{ELF Header}

\subsection{Machine Information}

For file identification in \texttt{e_ident}, the x86-64 architecture
requires the following values.

\begin{table}[h]
  \begin{center}
    \begin{tabular}[t]{l|l}
      \multicolumn{1}{c}{Position} & \multicolumn{1}{c}{Value} \\
      \hline
      \texttt{e_ident[EI_CLASS]} & \texttt{ELFCLASS64} \\
      \texttt{e_ident[EI_DATA]} & \texttt{ELFDATA2LSB}
    \end{tabular}
  \end{center}
  \caption{x86-64 Identification}
\end{table}

\section{Sections}

No changes required.

\section{Symbol Table}

No changes required.

\section{Relocation}

\subsection{Relocation Types}

The x86-64 ABI adds one additional field:

\begin{figure}[h]
  \begin{picture}(300,100)
    \put(0,66){\framebox(150, 33){31\hfill\textit{word32}\hfill 0}}
    \put(0,0){\framebox(300, 33){63\hfill\textit{word64}\hfill 0}}
  \end{picture}
  \caption{Relocatable Fields}
\end{figure}

\noindent
\begin{tabular*}{\textwidth}{l@{\extracolsep{\fill}}p{4in}}
\textit{word32} & This specifies a 32-bit field occupying 4 bytes
                  with arbitrary byte alignment.  These values use
                  the smae byte order as other word values in the
                  x86-64 architecture. \\
\textit{word64} & This specifies a 64-bit field occupying 8 bytes
                  with arbitrary byte alignment.  These values use
                  the smae byte order as other word values in the
                  x86-64 architecture. \\
\end{tabular*}

The x86-64 ABI architectures uses only \texttt{Elf64_Rel} relocation
entries.

\begin{figure}[h]
  \begin{center}
    \begin{tabular}[t]{l|r|l|l}
      \multicolumn{1}{c}{Name} & 
      \multicolumn{1}{c}{Value} & 
      \multicolumn{1}{c}{Field} & 
      \multicolumn{1}{c}{Calculation} \\
      \hline
      \texttt{R_X8664_NONE}  & 0 & none & none \\
      \texttt{R_X8664_64}    & 1 & \textit{word64} & \texttt{S + A} \\
      \texttt{R_X8664_PC32}  & 2 & \textit{word32} & \texttt{S + A - P} \\
      \texttt{R_X8664_GOT32} & 3 & \textit{word32} & \texttt{G + A - P} \\
      \texttt{R_X8664_PLT64} & 4 & \textit{word64} & \texttt{L + A - P} \\
      \texttt{R_X8664_COPY}  & 5 & none            & none \\
      \texttt{R_X8664_GLOB_DATA} & 6 & \textit{word64} & \texttt{S} \\
      \texttt{R_X8664_JMP_SLOT} & 7 & \textit{word64} & \texttt{S} \\
      \texttt{R_X8664_RELATIVE} & 8 & \textit{word64} & \texttt{B + A} \\
      \texttt{R_X8664_GOTOFF} & 9 & \textit{word64} & \texttt{S + A - GOT} \\
      \texttt{R_X8664_GOTPC} & 10 & \textit{word64} & \texttt{GOT + A - P} \\
    \end{tabular}
  \end{center}
  \caption{Relocation Types}
\end{figure}

The special semantics for these relocation types are identical to
those used for the Intel386 architecture.
\footnote{Even though the x86-64 architecture supports IP-relative
  addressing modes, a GOT is still required since the address from the
  a particular instruction to a particular data item cannot be
  known by the static linker.}
\footnote{Note that the
  x86-64 architecture assumes that GOT offsets remain 32-bit values.
  This choice means that a maximum of $2^{32}/8 = 2^{29}$ entries can
  be placed in the GOT.  However, that should be more than enough for
  most programs.  In the event that it is not enough, the linker could
  create multiple GOTs.  Because 32-bit offsets are used, loads of
  global data do not require loading the offset into a displacement
  register; the base plus immediate displacement addressing form can
  be used.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
