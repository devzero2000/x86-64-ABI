
\chapter{Object Files}

\section{ELF Header}

\subsection{Machine Information}

For file identification in \texttt{e_ident}, the \xARCH architecture
requires the following values.

\begin{table}[H]
\Hrule
  \caption{\xARCH Identification}
  \begin{center}
    \begin{tabular}[t]{l|l}
      \multicolumn{1}{c}{Position} & \multicolumn{1}{c}{Value} \\
      \hline
      \texttt{e_ident[EI_CLASS]} & \texttt{ELFCLASS64} \\
      \texttt{e_ident[EI_DATA]} & \texttt{ELFDATA2LSB}
    \end{tabular}
  \end{center}
\Hrule
\end{table}

Processor identification resides in the ELF header's
\texttt{e_machine} member and must have the value
\texttt{EM_X86_64}.\footnote{The value of this identifier is 62.}

\section{Sections}

No changes required.

\section{Symbol Table}

No changes required.

\section{Relocation}

\subsection{Relocation Types}

The \xARCH ABI adds one additional field:

\begin{figure}[H]
\Hrule
  \caption{Relocatable Fields}
\begin{center}
  \begin{picture}(360,190)
    \put(0,150){\framebox(50, 33){7\hfill\textit{word8}\hfill 0}}
    \put(0,100){\framebox(90, 33){15\hfill\textit{word16}\hfill 0}}
    \put(0,50){\framebox(180, 33){31\hfill\textit{word32}\hfill 0}}
    \put(0,0){\framebox(360, 33){63\hfill\textit{word64}\hfill 0}}
  \end{picture}
\end{center}
\Hrule
\end{figure}

\noindent
\begin{tabular*}{\textwidth}{l@{\extracolsep{\fill}}p{4in}}
\textit{word8} & This specifies a 8-bit field occupying 1 byte.\\
\textit{word16} & This specifies a 16-bit field occupying 2 bytes
                  with arbitrary byte alignment.  These values use
                  the same byte order as other word values in the
                  \xARCH architecture. \\
\textit{word32} & This specifies a 32-bit field occupying 4 bytes
                  with arbitrary byte alignment.  These values use
                  the same byte order as other word values in the
                  \xARCH architecture. \\
\textit{word64} & This specifies a 64-bit field occupying 8 bytes
                  with arbitrary byte alignment.  These values use
                  the same byte order as other word values in the
                  \xARCH architecture. \\
\end{tabular*}

The following notations are used for specifying relocations in table
\ref{tab-relocations}:
\begin{description}
\item[A] Represents the addend used to compute the value of the
  relocatable field.
\item[B] Represents the base address at which a shared object has been
  loaded into memory during execution.  Generally, a shared object is
  built with a 0 base virtual address, but the execution address will
  be different.
\item[G] Represents the offset into the global offset table at which 
  the relocation entry's symbol will reside during execution.
\item[GOT] Represents the address of the global offset table.
\item[L] Represents the place (section offset or address) of the
  \textindex{Procedure Linkage Table} entry for a symbol.
\item[P] Represents the place (section offset or address) of the
  storage unit being relocated (computed using \code{r_offset}).
\item[S] Represents the value of the symbol whose index resides in the
  relocation entry.
\end{description}

The \xARCH ABI architectures uses only \texttt{Elf64_Rela} relocation
entries with explicit addends.  The \code{r_addend} member serves as
the relocation addend.

\begin{table}[H]
\Hrule
  \caption{Relocation Types}
  \label{tab-relocations}
  \begin{center}
    \begin{tabular}[t]{l|r|l|l}
      \multicolumn{1}{c}{Name} & 
      \multicolumn{1}{c}{Value} & 
      \multicolumn{1}{c}{Field} & 
      \multicolumn{1}{c}{Calculation} \\
      \hline
      \texttt{R_X86_64_NONE}  & 0 & none & none \\
      \texttt{R_X86_64_64}    & 1 & \textit{word64} & \texttt{S + A} \\
      \texttt{R_X86_64_PC32}  & 2 & \textit{word32} & \texttt{S + A - P} \\
      \texttt{R_X86_64_GOT32} & 3 & \textit{word32} & \texttt{G + A} \\
      \texttt{R_X86_64_PLT32} & 4 & \textit{word32} & \texttt{L + A - P} \\
      \texttt{R_X86_64_COPY}  & 5 & none            & none \\
      \texttt{R_X86_64_GLOB_DAT} & 6 & \textit{word64} & \texttt{S} \\
      \texttt{R_X86_64_JUMP_SLOT} & 7 & \textit{word64} & \texttt{S} \\
      \texttt{R_X86_64_RELATIVE} & 8 & \textit{word64} & \texttt{B + A} \\
      \texttt{R_X86_64_GOTPCREL} & 9 & \textit{word32} & \texttt{G + GOT + A - P} \\
      \texttt{R_X86_64_32}    & 10 & \textit{word32} & \texttt{S + A} \\
      \texttt{R_X86_64_32S}   & 11 & \textit{word32} & \texttt{S + A} \\
      \texttt{R_X86_64_16}    & 12 & \textit{word16} & \texttt{S + A} \\
      \texttt{R_X86_64_PC16}  & 13 & \textit{word16} & \texttt{S + A - P} \\
      \texttt{R_X86_64_8}     & 14 & \textit{word8} & \texttt{S + A} \\
      \texttt{R_X86_64_PC8}   & 15 & \textit{word8} & \texttt{S + A - P} \\
%      \texttt{R_X86_64_GOT64} & 16 & \textit{word64} & \texttt{G + A} \\
%      \texttt{R_X86_64_PLT64} & 17 & \textit{word64} & \texttt{L + A - P} \\
    \end{tabular}
  \end{center}
\Hrule
\end{table}

The special semantics for most of these relocation types are identical
to those used for the Intel386 architecture.  \footnote{Even though
  the \xARCH architecture supports IP-relative addressing modes, a GOT
  is still required since the offset from a particular instruction to
  a particular data item cannot be known by the static linker.}
\footnote{Note that the \xARCH architecture assumes that offsets into
  GOT are 32-bit values, not 64-bit values.  This choice means that a
  maximum of $2^{32}/8 = 2^{29}$ entries can be placed in the GOT.
  However, that should be more than enough for most programs.  In the
  event that it is not enough, the linker could create multiple GOTs.
  Because 32-bit offsets are used, loads of global data do not require
  loading the offset into a displacement register; the base plus
  immediate displacement addressing form can be used.}

The \texttt{R_X86_64_GOTPCREL} relocation has different semantics from
the i386 \texttt{R_I386_GOTPC} relocation.  In particular, because the
\xARCH architecture has an addressing mode relative to the instruction
pointer, it is possible to load an address from the GOT using a single
instruction.  The calculation done by the \texttt{R_X86_64_GOTPCREL}
relocation gives the difference between the location in the GOT where
the symbol's address is given and the location where the relocation is
applied.

\begin{sloppypar}
The \texttt{R_X86_64_32} and \texttt{R_X86_64_32S} relocations truncate
the computed value to 32-bits.  The linker must verify that the
generated value for the \texttt{R_X86_64_32} (\texttt{R_X86_64_32S})
relocation zero-extends (sign-extends) to the original 64-bit value.
\end{sloppypar}

\begin{sloppypar}
A program or object file using \texttt{R_X86_64_8},
\texttt{R_X86_64_16}, \texttt{R_X86_64_PC16} or \texttt{R_X86_64_PC8}
relocations is not conformant to this ABI, these relocations are only
added for documentation purposes.  The \texttt{R_X86_64_16}, and
\texttt{R_X86_64_8} relocations truncate the computed value to 16-bits
resp. 8-bits.
\end{sloppypar}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
