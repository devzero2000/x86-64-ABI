\chapter{Program Loading and Dynamic Linking}


\section{Program Loading}

No changes required.


\section{Dynamic Linking}

We need three parameters for the dynamic linker to fix up the
PLT:
\begin{enumerate}
\item The address of the entry point of the dynamic linker.
\item The relocation entry that needs to be relocated (either GOT or
  PLT, depending on the proposal)
\item A special parameter to identify the shared object.
\end{enumerate}

\editornote{A location for these parameters has to be determined.}

\editornote{So far only the conventions for shared objects have been
  specified.  The conventions for the executable need to be written
  down.}
% executable: PIC or not PIC?

\subsubsection{Dynamic Section}

No changes required.

\subsubsection{Global Offset Table}

\index{global offset table}

\editornote{Some minor changes might be required, depending on the
  proposal.  This will be clarified later.}

\begin{figure}[H]
\caption{Global Offset Table}
\begin{center}
\fbox{\code{extern Elf64_Addr _GLOBAL_OFFSET_TABLE_ [];}}
\end{center}
\end{figure}

\subsubsection{Function Addresses}

No changes required.

\subsubsection{Procedure Linkage Table}

\editornote{Either of the three proposals will be implemented.  Some
  details need to filled in, like the number of reserved entries and
  the exact algorithm used.}

\paragraph{Proposal 1: RW-PLT}

% This has been copied from the i386 ABI and the SPARC ABI.

Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in private data.  The dynamic linker
determines the destinations' absolute addresses and modifies the the
procedure linkage table's memory image accordingly.  The dynamic
linker thus can redirect the entries without compromising the
position-independence and shareability of the program's text.
Executable files and shared object files have separate procedure
linkage tables.

\begin{figure}[H]
\caption{Position-Independent Direct Function Call}
\begin{verbatim}
extern void function ();  .globl function
function ();              call function@PLT
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Position-Independent Indirect Function Call}
\begin{verbatim}
extern void (*ptr) ();    .globl ptr, name
extern void name ();
ptr = name;               movl ptr@GOTPC(%rip), %rax
                          movl name@GOTPC(%rip), %rdx
                          movl %rdx, (%rax)

(*ptr)();                 movl ptr@GOTPC(%rip), %rax
                          call *(%rax)
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Absolute Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & got\_plus\_8; GOT[1]\\
& jmp &got\_plus\_16 ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp & .PLT1a \\
.PLT1a& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp& name2\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}


\begin{figure}[H]
\caption{Position-Independent Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp & PLT1a\\
.PLT1a& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp& name2\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}

\editornote{The costs for a call are (after fixing the PLT): one call
  and one direct jmp, giving an overhead of one jump.  The problem is
  that we have self modifying code.}

\paragraph{Proposal 2: RO-PLT}

\editornote{This is ia32 enhanced to 64 bits without an explicit GOT
  register.}

% This has been copied from the i386 ABI.
Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in shared text, but they use address
in the private global offset table.  The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly.  The dynamic linker thus can
redirect the entries without compromising the position-independence
and shareability of the program's text.  Executable files and shared
object files have separate procedure linkage tables.  



\begin{figure}[H]
\caption{Position-Independent Direct Function Call}
\begin{verbatim}
extern void function ();  .globl function
function ();              call function@PLT
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Absolute Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & got\_plus\_8; GOT[1]\\
& jmp &got\_plus\_16 ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp & *name1\_in\_GOT\\
.PLT1a& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp& *name2\_in\_GOT\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}

\begin{figure}[H]
\caption{Position-Independent Indirect Function Call}
\begin{verbatim}
extern void (*ptr) ();    .globl ptr, name
extern void name ();
ptr = name;               movl ptr@GOTPC(%rip), %rax
                          movl name@GOTPC(%rip), %rdx
                          movl %rdx, (%rax)

(*ptr)();                 movl ptr@GOTPC(%rip), %rax
                          call *(%rax)
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Position-Independent Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp &*name1@GOTPC(\%rip)\\
& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp&*name2@GOTPC(\%rip)\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}

\editornote{The costs for a call are (after fixing the PLT): one call
  and one memory indirect jmp, giving an overhead of one jump and one
  memory reference.}

\paragraph{Proposal 3: Indirect Calls}

%\editornote{This was suggested to me by Wayne Meretsky}

\editornote{Since we only relocate the GOT entries, we have a
  read-only PLT.  The disadvantage of this proposal is that
  executables need to be compiled as PIC.}

% This has been copied from the i386 ABI.
Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in shared text, but they use address
in the private global offset table.  The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly.  The dynamic linker thus can
redirect the entries without compromising the position-independence
and shareability of the program's text.  Executable files and shared
object files have separate procedure linkage tables.  

\begin{figure}[H]
\caption{Position-Independent Direct Function Call}
\begin{verbatim}
extern void function ();  .globl function
function ();              call *name@GOTPC(%rip)
\end{verbatim}
\end{figure}


\begin{figure}[H]
\caption{Position-Independent Indirect Function Call}
\begin{verbatim}
extern void (*ptr) ();    .globl ptr, name
extern void name ();
ptr = name;               movl ptr@GOTPC(%rip), %rax
                          movl name@GOTPC(%rip), %rdx
                          movl %rdx, (%rax)

(*ptr)();                 movl ptr@GOTPC(%rip), %rax
                          call *(%rax)
\end{verbatim}
\end{figure}


\begin{figure}[H]
\caption{Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: &pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}


\editornote{The costs for a call are (after fixing the PLT): one
  memory indirect call, giving an overhead of one memory reference.}

\paragraph{Comparison of Proposals}

\begin{figure}
\caption{Comparison of Different PLT Proposals}

\begin{center}
\begin{tabular}{llll}
    \hline\noalign{\smallskip}
&RW-PLT & RO-PLT & Indirect Calls \\
    \noalign{\smallskip}\hline\noalign{\smallskip}
PLT location & private data & shared text & shared text \\
Address location & PLT & GOT & GOT \\
Overhead after relocation & 1 jump & 1 memory ref. & 1 memory ref.\\
&&and 1 jump &  \\
Self modifying code? & Yes &  No & No\\
Executable is PIC? & No & No & Yes \\
Other ABIs & Sparc & i386 & None? \\
\end{tabular}
\end{center}
\end{figure}
                                

% common stuff
\subsection{Program Interpreter}

The name and location of the program interpreter \index{program
  interpreter} is%
\footnote{Every Operating System will change this.
  For example Linux will use \path{/lib/ld-linux-x86-64.so.1}.}:

\bigskip
\path{/usr/lib/ld.so.1}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "abi"
%%% End:
