\chapter{Program Loading and Dynamic Linking}


\section{Program Loading}

No changes required.


\section{Dynamic Linking}

We need three parameters for the dynamic linker to fix up the
PLT:
\begin{enumerate}
\item The address of the entry point of the dynamic linker.
\item The relocation entry that needs to be relocated (either GOT or
  PLT, depending on the proposal)
\item A special parameter to identify the shared object.
\end{enumerate}

\editornote{A location for these parameters has to be determined.}

\editornote{So far only the conventions for shared objects have been
  specified.  The conventions for the executable need to be written
  down.}
% executable: PIC or not PIC?

\subsubsection{Dynamic Section}

No changes required.

\subsubsection{Global Offset Table}

\index{global offset table}

\editornote{Some minor changes might be required, depending on the
  proposal.  This will be clarified later.}

\begin{figure}[H]
\caption{Global Offset Table}
\begin{center}
\fbox{\code{extern Elf64_Addr _GLOBAL_OFFSET_TABLE_ [];}}
\end{center}
\end{figure}

\subsubsection{Function Addresses}

No changes required.

\subsubsection{Procedure Linkage Table}

\editornote{Either of the three proposals will be implemented.  Some
  details need to filled in, like the number of reserved entries and
  the exact algorithm used.}


\bigskip\hrule

\paragraph{Proposal 1: RW-PLT}

% This has been copied from the i386 ABI and the SPARC ABI.

Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in private data.  The dynamic linker
determines the destinations' absolute addresses and modifies the the
procedure linkage table's memory image accordingly.  The dynamic
linker thus can redirect the entries without compromising the
position-independence and shareability of the program's text.
Executable files and shared object files have separate procedure
linkage tables.

%\begin{figure}[H]
%\caption{Position-Independent Direct Function Call}
%\begin{verbatim}
%extern void function ();  .globl function
%function ();              call function@PLT
%\end{verbatim}
%\end{figure}
%
%\begin{figure}[H]
%\caption{Position-Independent Indirect Function Call}
%\begin{verbatim}
%extern void (*ptr) ();    .globl ptr, name
%extern void name ();
%ptr = name;               movl ptr@GOTPC(%rip), %rax
%                          movl name@GOTPC(%rip), %rdx
%                          movl %rdx, (%rax)
%
%(*ptr)();                 movl ptr@GOTPC(%rip), %rax
%                          call *(%rax)
%\end{verbatim}
%\end{figure}


\editornote{The proposal needs serious discussing and feasibility
  checking.   The PLT entries should also be aligned.  The proposal
  should work with 8 byte atomic moves.}

\begin{figure}[H]
\caption{Position-Independent Procedure Linkage Table}
\begin{center}
\begin{tabular}{lll|lll}
\multicolumn{3}{c}{Object File} & \multicolumn{3}{c}{Memory Segment} \\
\hline
.PLT0: &  && .PLT0: &\\
& \dots &  \\
.PLT1: & nop &&.PLT1:& .dword& identification \\
& \dots & \\
&\dots && \dots \\
.PLT10: & mv & R9, index  & .PLT10: & nop;nop;\\
 &  &   &  & nop;nop\\
 &  &   &  & nop;nop\\
& jmp & .PLT0 && mv & R9, address \\
& nop;nop &&& jmp & *(R9)  \\
& nop;nop && & \\
& nop;nop && & \\
& nop;nop && & \\
&\dots && \dots \\
\end{tabular}
\end{center}

% NOP is 1 byte
%
\end{figure}

\editornote{R9 is a temporary register and can therefore be
  overwritten --- any other temporary register can be used instead and
  we should consider using one of the ``normal'' registers so that we
  do not need a prefix.}


\editornote{The costs for a call are (after fixing the PLT): one call;
  one load and one direct jmp, giving an overhead of one load and one
  jump.  The problem is that we have self modifying code.}

\bigskip\hrule

\paragraph{Proposal 2: RO-PLT}

\editornote{This is ia32 enhanced to 64 bits without an explicit GOT
  register.}

% This has been copied from the i386 ABI.
Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in shared text, but they use address
in the private global offset table.  The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly.  The dynamic linker thus can
redirect the entries without compromising the position-independence
and shareability of the program's text.  Executable files and shared
object files have separate procedure linkage tables.  



\begin{figure}[H]
\caption{Position-Independent Direct Function Call}
\begin{verbatim}
extern void function ();  .globl function
function ();              call function@PLT
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Absolute Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & got\_plus\_8; GOT[1]\\
& jmp &got\_plus\_16 ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp & *name1\_in\_GOT\\
.PLT1a& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp& *name2\_in\_GOT\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}

\begin{figure}[H]
\caption{Position-Independent Indirect Function Call}
\begin{verbatim}
extern void (*ptr) ();    .globl ptr, name
extern void name ();
ptr = name;               movl ptr@GOTPC(%rip), %rax
                          movl name@GOTPC(%rip), %rdx
                          movl %rdx, (%rax)

(*ptr)();                 movl ptr@GOTPC(%rip), %rax
                          call *(%rax)
\end{verbatim}
\end{figure}

\begin{figure}[H]
\caption{Position-Independent Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp &*name1@GOTPC(\%rip)\\
& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp&*name2@GOTPC(\%rip)\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}

\editornote{The costs for a call are (after fixing the PLT): one call
  and one memory indirect jmp, giving an overhead of one jump and one
  memory reference.}

Following the steps below, the dynamic linker and the program
``cooperate'' to resolve symbolic references through the procedure
linkage table and the global offset table.

\begin{enumerate}
\item When first creating the memory image of the program, the dynamic
  linker sets the second and the third entries in the global offset
  table to special values.  Steps below explain more about these
  values.
\item Each shared object file in the process image has its own
  procedure linkage table, and control transfers to a procedure
  linkage table entry only from within the same object file.
\editornote{Should we remove this completely?}
\item For illustration, assume the program calls \code{name1}, which
  transfers control to the label \code{.PLT1}.
\item The first instruction jumps to the address in the global offset
  table entry for \code{name1}.  Initially the global offset table
  holds the address of the following \code{pushl} instruction, not the
  real address of \code{name1}.
\item After pushing the relocation offset, the program then jumps to
  \code{.PLT0}, the first entry in the procedure linkage table.  The
  \code{pushl} instruction places the value of the second global
  offset table entry (GOT+8) on the stack, thus giving the dynamic
  linker one word of identifying information.  The program then jumps
  to the address in the third global offset table entry (GOT+16),
  which transfers control to the dynamic linker.
\item When the dynamic linker receives control, it unwinds the stack,
  looks at the designated relocation entry, finds the symbol's value,
  stores the ``real'' address for \code{name1} in its global offset
  table entry, and transfers control to the desired destination.
\item Subsequent executions of the procedure linkage table entry will
  transfer directly to \code{name1}, without calling the dynamic
  linker a second time.  That is, the \code{jmp} instruction at
  \code{.PLT1} will transfer to \code{name1}, instead of ``falling
  through'' to the \code{pushl} instruction.
\end{enumerate}

The \code{LD_BIND_NOW} environment variable can change the dynamic
linking behavior.  If its value is non-null, the dynamic linker
evaluates procedure linkage table entries before transferring control
to the program.  That is, the dynamic linker processes relocation
entries of type \code{R_X8664_JMP_SLOT} \index{R_X8664_JMP_SLOT}
during process initialization.  Otherwise, the dynamic linker
evaluates procedure linkage table entries lazily, delaying symbol
resolution and relocation until the first execution of a table entry.

\bigskip\hrule

\paragraph{Proposal 3: Indirect Calls}

%\editornote{This was suggested to me by Wayne Meretsky}

\editornote{Since we only relocate the GOT entries, we have a
  read-only PLT.  The disadvantage of this proposal is that
  executables need to be compiled as PIC.}

% This has been copied from the i386 ABI.
Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in shared text, but they use address
in the private global offset table.  The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly.  The dynamic linker thus can
redirect the entries without compromising the position-independence
and shareability of the program's text.  Executable files and shared
object files have separate procedure linkage tables.  

\begin{figure}[H]
\caption{Position-Independent Direct Function Call}
\begin{verbatim}
extern void function ();  .globl function
function ();              call *name@GOTPC(%rip)
\end{verbatim}
\end{figure}


\begin{figure}[H]
\caption{Position-Independent Indirect Function Call}
\begin{verbatim}
extern void (*ptr) ();    .globl ptr, name
extern void name ();
ptr = name;               movl ptr@GOTPC(%rip), %rax
                          movl name@GOTPC(%rip), %rdx
                          movl %rdx, (%rax)

(*ptr)();                 movl ptr@GOTPC(%rip), %rax
                          call *(%rax)
\end{verbatim}
\end{figure}


\begin{figure}[H]
\caption{Procedure Linkage Table}
\begin{tabular}{lll}
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: &pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots\\
\end{tabular}
\end{figure}


\editornote{The costs for a call are (after fixing the PLT): one
  memory indirect call, giving an overhead of one memory reference.}

\bigskip\hrule

\paragraph{Comparison of Proposals}

The following table compares the proposals for PLT/GOT usage:

\begin{figure}[H]
\caption{Comparison of Different PLT Proposals}

\begin{center}
\begin{tabular}{llll}
    \hline\noalign{\smallskip}
&RW-PLT & RO-PLT & Indirect Calls \\
    \noalign{\smallskip}\hline\noalign{\smallskip}
PLT location & private data & shared text & shared text \\
Address location & PLT & GOT & GOT \\
Overhead after relocation & 1 memory ref. & 1 memory ref. & 1 memory ref.\\
&and 1 jump &and 1 jump &  \\
Self modifying code? & Yes &  No & No\\
Executable is PIC? & No & No & Yes \\
Other ABIs & Sparc & i386 & None? \\
\end{tabular}
\end{center}
\end{figure}
                                

\bigskip\hrule

% common stuff
\subsection{Program Interpreter}

The name and location of the program interpreter \index{program
  interpreter} is%
\footnote{Every Operating System will change this.
  For example Linux will use \path{/lib/ld-linux-x86-64.so.1}.}:

\bigskip
\path{/usr/lib/ld.so.1}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "abi"
%%% End:
