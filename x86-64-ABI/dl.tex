\chapter{Program Loading and Dynamic Linking}

\section{Program Loading}

No changes required.


\section{Dynamic Linking}

\subsubsection{Dynamic Section}

No changes required.

\subsubsection{Global Offset Table}

The only difference is in the size of the \textindex{global offset table}, it
contains 64 bit addresses.

\begin{figure}[H]
\Hrule
\caption{Global Offset Table}
\begin{center}
\fbox{\code{extern Elf64_Addr _GLOBAL_OFFSET_TABLE_ [];}}
\end{center}
\Hrule
\end{figure}

\subsubsection{Function Addresses}

No changes required.

\subsubsection{Procedure Linkage Table}


%This is ia32 enhanced to 64 bits without an explicit GOT
%  register.

% This has been copied from the i386 ABI.
\index{procedure linkage table|(}
Much as the global offset table redirects position-independent address
calculations to absolute locations, the procedure linkage table
redirects position-independent function calls to absolute locations.
The link editor cannot resolve execution transfers (such as function
calls) from one executable or shared object to another.  Consequently,
the link editor arranges to have the program transfer control to
entries in the procedure linkage table.  On the \xARCH architecture,
procedure linkage tables reside in shared text, but they use address
in the private global offset table.  The dynamic linker determines the
destinations' absolute addresses and modifies the global offset
table's memory image accordingly.  The dynamic linker thus can
redirect the entries without compromising the position-independence
and shareability of the program's text.  Executable files and shared
object files have separate procedure linkage tables.


\begin{figure}[H]
\Hrule
\caption{Absolute Procedure Linkage Table}
\begin{center}
\begin{tabular}{|lll|}
\hline
.PLT0: & pushl & got\_plus\_8; GOT[1]\\
& jmp &got\_plus\_16 ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp & *name1\_in\_GOT\\
.PLT1a& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp& *name2\_in\_GOT\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots&\\
\hline
\end{tabular}
\end{center}
\Hrule
\end{figure}


\begin{figure}[H]
\Hrule
\caption{Position-Independent Procedure Linkage Table}
\begin{center}
\begin{tabular}{|lll|}
\hline
.PLT0: & pushl & GOT+8(\%rip); GOT[1]\\
& jmp &GOT+16(\%rip) ; GOT[2] \\
& nop & \\
& nop & \\
& nop & \\
& nop & \\
.PLT1: & jmp &*name1@GOTPC(\%rip)\\
& pushl & \$offset \\
&jmp &.PLT0@PC \\
.PLT2: & jmp&*name2@GOTPC(\%rip)\\
&pushl & \$offset \\
& jmp & .PLT0@PC \\
&\dots &\\
\hline
\end{tabular}
\end{center}
\Hrule
\end{figure}

Following the steps below, the dynamic linker and the program
``cooperate'' to resolve symbolic references through the procedure
linkage table and the global offset table.

\begin{enumerate}
\item When first creating the memory image of the program, the dynamic
  linker sets the second and the third entries in the global offset
  table to special values.  Steps below explain more about these
  values.
\item Each shared object file in the process image has its own
  procedure linkage table, and control transfers to a procedure
  linkage table entry only from within the same object file.
\editornote{Should we remove this completely?}
\item For illustration, assume the program calls \code{name1}, which
  transfers control to the label \code{.PLT1}.
\item The first instruction jumps to the address in the global offset
  table entry for \code{name1}.  Initially the global offset table
  holds the address of the following \code{pushl} instruction, not the
  real address of \code{name1}.
\item After pushing the relocation offset, the program then jumps to
  \code{.PLT0}, the first entry in the procedure linkage table.  The
  \code{pushl} instruction places the value of the second global
  offset table entry (GOT+8) on the stack, thus giving the dynamic
  linker one word of identifying information.  The program then jumps
  to the address in the third global offset table entry (GOT+16),
  which transfers control to the dynamic linker.
\item When the dynamic linker receives control, it unwinds the stack,
  looks at the designated relocation entry, finds the symbol's value,
  stores the ``real'' address for \code{name1} in its global offset
  table entry, and transfers control to the desired destination.
\item Subsequent executions of the procedure linkage table entry will
  transfer directly to \code{name1}, without calling the dynamic
  linker a second time.  That is, the \code{jmp} instruction at
  \code{.PLT1} will transfer to \code{name1}, instead of ``falling
  through'' to the \code{pushl} instruction.
\end{enumerate}

The \code{LD_BIND_NOW} environment variable can change the dynamic
linking behavior.  If its value is non-null, the dynamic linker
evaluates procedure linkage table entries before transferring control
to the program.  That is, the dynamic linker processes relocation
entries of type \codeindex{R_X8664_JMP_SLOT}
during process initialization.  Otherwise, the dynamic linker
evaluates procedure linkage table entries lazily, delaying symbol
resolution and relocation until the first execution of a table entry.
\index{procedure linkage table|)}

\subsection{Program Interpreter}

There is one valid \textindex{program interpreter} for
programs conforming to the \xARCH ABI:

\bigskip
\path{/usr/lib/ld64.so.1}

\subsection{Initialization and Termination Functions}

% copied from ia64
The implementation is responsible for executing the initialization
functions specified by \codeindex{DT_INIT}, \codeindex{DT_INIT_ARRAY},
and \codeindex{DT_PREINIT_ARRAY} entries in the executable file and
shared object files for a process, and the termination (or
finalization) functions specified by \codeindex{DT_FINI} and
\codeindex{DT_FINI_ARRAY}, as specified by the \textit{System V ABI}.
The user program plays no further part in executing the initialization
and termination functions specified by these dynamic tags.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "abi"
%%% End:
