\chapter{Low Level System Information}

\section{Machine Interface}

\subsection{Processor Architecture}

\subsection{Data Representation}

Within this specification, the term \emph{halfword} refers to a 16-bit
object, the term \emph{word} refers to a 32-bit object, the term
\emph{doubleword} refers to a 64-bit object, and the term
\emph{quadword} refers to a 128-bit object.

\subsubsection{Fundamental Types}

Figure~\ref{basic-types} shows the correspondence between ISO C's
scalar types and the processor's.

\begin{figure}
  \caption{Scalar Types}\label{basic-types}
{ % Use small here - the table is still too large
  % Has anybody an idea how to shrink the table so that it fits the page?
  \small
  \begin{tabular}{l|l|c|c|l}
    \hline\noalign{\smallskip}
     & &  & \multicolumn{1}{c|}{Alignment} & \multicolumn{1}{c|}{x86-64} \\
    \multicolumn{1}{c|}{Type} & \multicolumn{1}{c|}{C}
     &  \texttt{sizeof} & (bytes)
     & \multicolumn{1}{c|}{Architecture}  \\
    \hline
    & \texttt{char}        & 1 & 1 & signed byte \\
    & \texttt{signed char} & & \\
    \cline{2-5}
    & \texttt{unsigned char} & 1 & 1 & unsigned byte \\
    \cline{2-5}
    & \texttt{short} & 2 & 2 & signed halfword \\
    & \texttt{signed short} & & \\
    \cline{2-5}
    & \texttt{unsigned short} & 2 & 2 & unsigned halfword \\
    \cline{2-5}
    & \texttt{int} & 4 & 4 & signed word \\
    Integral & \texttt{signed int} & & \\
    & \texttt{enum} & & \\
    \cline{2-5}
    & \texttt{unsigned int} & 4 & 4 & unsigned word \\
    \cline{2-5}
    & \texttt{long} & 8 & 8 & signed doubleword \\
    & \texttt{signed long} & & \\
    & \texttt{long long} & & \\
    & \texttt{signed long long} & & \\
    \cline{2-5}
    & \texttt{unsigned long} & 8 & 8 & unsigned doubleword \\
    & \texttt{unsigned long long} & 8 & 8 & unsigned doubleword \\
    \hline
    & \texttt{__int128} & 16 & 16 & signed quadword \\
    & \texttt{signed __int128} & 16 & 16 & signed quadword \\
    \hline
    & \texttt{unsigned __int128} & 16 & 16 & unsigned quadword \\
    \hline
    Pointer & \texttt{\textit{any-type} *} & 8 & 8 & unsigned doubleword \\
    & \texttt{\textit{any-type} (*)()} & & \\
    \hline
    Floating-& \texttt{float} & 4 & 4 & single (IEEE) \\
    point & \texttt{double} & 8 & 8 & double (IEEE) \\
    & \texttt{long double} & 16 & 16 & 80-bit extended (IEEE) \\
    & \texttt{__float128} & 16 & 16 & 128-bit extended (IEEE) \\
    \hline
    Packed & \texttt{__m64} & 8 & 8 & \MMX{} and \threednow \\
    & \texttt{__m128} & 16 & 16 & SSE and SSE-2 \\
  \end{tabular}
}
\end{figure}

The \codeindex{__float128} type uses a 15-bit exponent, a 113-bit
mantissa (the high order significant bit is implicit) and an exponent
bias of 16383.\footnote{Initial implementations of the \xARCH
  architecture are expected to support operations on the
  \texttt{__float128} type only via software emulation.}

The \code{long double} type uses a 15 bit exponent, a 64-bit mantissa
with an explicit high order significand bit and an exponent bias of
16383.\footnote{This type is the x87 double extented precision data
  type.}  Although a \code{long double} requires 16 bytes of storage,
only the first 10 bytes are significant.  The remaining six bytes are
tail padding, and the contents of these bytes are undefined.

The \code{__int128} type is stored in little-endian order in memory,
i.e., the 64 low-order bits are stored at a a lower address than the
64 high-order bits.

A null pointer (for all types) has value zero.

Like the Intel386 architecture, the \xARCH architecture does not
require all data access to be properly aligned.  Accessing misaligned
data will be slower than accessing properly aligned data, but
otherwise there is no difference.

\subsubsection{Aggregates and Unions}

An array uses the same alignment as its elements, except that a local
or global array variable that requires at least 16 bytes, or a C99
local or global variable-length array variable, always has alignment
of at least 16 bytes.\footnote{The alignment requirement allows the
  use of SSE instructions when operating on the array.  The compiler
  cannot in general calculate the size of a variable-length array, but
  it is expected that most VLAs will require at least 16 bytes, so it
  is logical to mandate that VLAs have at least a 16-byte alignment.}

No other changes required.

\subsubsection{Bit-Fields}

Amend the description of bit-field ranges as follows:

\begin{figure}[h]
\Hrule
  \caption{Bit-Field Ranges}
  \begin{center}
    \leavevmode
    \begin{tabular}{l|l|l}
      \multicolumn{1}{c}{Bit-field Type}
         & \multicolumn{1}{c}{Width $w$}
         & \multicolumn{1}{c}{Range} \\
      \hline
      \texttt{signed long} & & $-2^{w - 1}$ to $2^{w-1}-1$ \\
      \texttt{long} & 1 to 64 & 0 to $2^{w}-1$ \\
      \texttt{unsigned long} & & 0 to $2^{w}-1$ \\
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

The ABI does not permit bitfields having the type \texttt{__m64} or
\texttt{__m128}.  Programs using bitfields of these types are not
portable.

No other changes required.

\section{Function Calling Sequence}

This section describes the standard function calling sequence,
including stack frame layout, register usage, parameter passing and so
on.

The standard calling sequence requirements apply only to global
functions.  Local functions that are not reachable from other
compilation units may use different conventions.  Nevertheless, it is
recommended that all functions use the standard calling sequence when
possible.

\subsection{Registers and the Stack Frame}
\label{subsec-registers}

The \xARCH architecture provides 16 general purpose 64-bit registers.
In addition the architecture provides 16 SSE registers, each 128 bits
wide and 8 x87 floating point registers, each 80 bits wide.  Each of
the x87 floating point registers may be referred to in \MMX/\threednow
mode as a 64-bit register.  All of these registesr are global to all
procedures in a running program.

This subsection discusses usage of each register.  Registers \RBP, \RBX and
\reg{r12} through \reg{r15} ``belong'' to the calling function and the
called function is required to preserve their values.  In other words,
a called function must preserve these registers' values for its
caller.  Remaining registers ``belong'' to the called
function.\footnote{Note that in contrast to the \intelabi, \RDI,
  and \RSI belong to the called function, not the caller.}  If a
calling function wants to preserve such a register value across a
function call, it must save the value in its local stack frame.

The CPU shall be in MMX mode upon entry to a function.  Therefore,
every function that uses the x87 register stack is required to issue
an \op{emms} or \op{femms} instruction before accessing the x87
register stack.\footnote{All \MMX{} registers are caller-saved, so
  callees that make use of the x87 register stack may use the faster
  \op{femms} instruction.}  The direction flag in the \reg{eflags}
register must be clear on function entry, and on function return.

\subsection{The Stack Frame}
In addition to registers, each function has a frame on the run-time
stack.  This stack grows downwards from high addresses.  Figure
\ref{fig-stack-frame} shows the stack organization.

\begin{figure}
\Hrule
  \caption{Stack Frame}
  \label{fig-stack-frame}
  \begin{center}
    \begin{tabular}{r|c|l}
      \noalign{\smallskip}
      \multicolumn{1}{l}{\bf Position} &
      \multicolumn{1}{c}{\bf Contents} &
      \multicolumn{1}{l}{\bf Frame} \\
      \noalign{\smallskip}  \cline{2-3}
      \code{8n+16(\RBP)} & argument doubleword $n$ \\
      & \dots & Previous \\
      \code{16(\RBP)} & argument doubleword $0$ \\
      \cline{1-3}
      \code{8(\RBP)} & return address \\ \cline{2-2}
      \code{0(\RBP)} & previous \RBP value \\
      \cline{2-2}
      \code{-8(\RBP)} & unspecified & Current \\
      & \dots & \\
      \code{0(\RSP)} & variable size \\
      \cline{2-2}
      \code{128(\RSP)} & red zone\\
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

The end of the input argument area shall be aligned on a 16 byte
boundary.  In other words, the value $(\RSP - 8)$ is always a multiple
of $16$ when control is transferred to the function entry point.  The
stack pointer, \RSP, always points to the end of the latest allocated
stack frame.  \footnote{The conventional use of \RBP{} as a frame
  pointer for the stack frame may be avoided by using \RSP (the stack
  pointer) to index into the stack frame.  This technique saves two
  instructions in the prologue and epilogue and makes one additional
  general-purpose register (\RBP) available.}

The 128-byte area beyond the location pointed to by \RSP is considered
to be reserved and shall not be modified by signal or interrupt
handlers.\footnote{Locations within 128 bytes can be addressed using
  one-byte displacements.}  Therefore, functions may use this area for
temporary data that is not needed across function calls.  In
particular, leaf functions may use this area for their entire stack
frame, rather than adjusting the stack pointer in the prologue and
epilogue.

\subsection{Parameter Passing}

After the argument values have been computed, they are placed in
registers, or pushed on the stack.  For the purpose of passing the
parameters, the arguments are considered from left (first argument) to
right. The arguments that are pushed on the stack are pushed in
reverse order.  Since the stack grows downwards, the rightmost
argument will have the highest address.\footnote{Right-to-left order
  makes the handling of functions that take a variable number of
  arguments simpler.  The location of the first argument can always be
  computed statically, based on the type of that argument.  It would
  be difficult to compute the address of the first argument if the
  arguments were pushed in left-to-right order.}

For each argument, the following method is used to determine the
location in which the argument is passed.  In all cases where a value
is pushed on the stack, the stack shall be left doubleword-aligned.
In all cases, the value pushed shall be located on a boundary whose
alignment is the maximum of 8 (doubleword alignment) and the alignment
of the type being pushed.  If the value does not consume the entire
doubleword, the contents of the unused storage located at higher
numbered addresses within the doubleword is undefined.

If the argument is a scalar type, other than \code{__m64} or
\code{__int128}, then it is placed in the next available register
suitable for its type.  In particular, arguments of integral or
pointer type are placed in the next available general purpose
register, taken in the order \RDI, \RSI, \RDX, \RCX, \reg{r8}, and
\reg{r9}.  \footnote{Note that \reg{r11} is neither required to
  be preserved, nor is it used to pass arguments.  Making this
  register available as scratch register means that code in the PLT
  need not spill any registers when computing the address to which
  control needs to be transferred.  \RAX is used to indicate the
  number of SSE arguments passed to a function requiring a variable
  number of arguments. \reg{r10} is used for passing a function's
  static chain pointer.}  Arguments of floating point type and of type
\code{__m128}, are placed in the next available SSE register, taken in
order from \reg{xmm0} to \reg{xmm15}.  If no registers are available,
the values are placed on the stack.

Scalar values of type \code{__int128} are handled almost as if they
consisted of two separate 64-bit arguments of type \code{long}.  The
64 low-order bits are considered to be the first argument, and
therefore processed second.\footnote{Thus, if the value is placed on
  the stack, the low-order bits will be at a lower address, which
  allows the caller to access the value normally.}  If there are not
enough registers available to allow passing both arguments in
registers, then the value is passed on the stack.

Scalar values of type \code{__m64} are always placed on the stack.

Structure or union objects with more than 16 bytes, those that contain
scalar components of type \code{__m64}, or, in C++,
non-POD\footnote{The term POD is from the ANSI/ISO C++ Standard, and
  stands for Plain Ol' Data.  Although the exact definition is
  technical, a POD is essentially a structure or union that could
  could have been written in C; there cannot be any member functions,
  or base classes, or similar C++ extensions.}  structure or union
types,\footnote{A non-POD object cannot be returned in registers
  because such objects must have well defined addresses; the address
  at which an object is constructed (by the caller) and the address at
  which the object is destroyed (by the callee) must be the same.
  Similar issues apply when returning a non-POD object from a
  function.} are always passed on the stack.  The stack is aligned as
required by the alignment of the structure or union type being passed.
Then, the structure value is copied onto the stack.

Structure or union objects that contain no more than 16 bytes and, in
C++, are PODs, are passed in registers, if registers are available.
If the entire structure cannot be placed in registers as described
below, then the structure is passed on the stack, as above.

If the structure contains a single scalar component, then it is passed
as if it were a single argument of that scalar type.

Otherwise, the first (or only, if the structure has no more than 8
bytes), doubleword of the structure is passed first.  If there is only
one component, the argument is passed as if it were an argument of
that type.  Otherwise, if all scalar components in the first component
are of floating point type, the first doubleword is passed as if it
were an argument of floating point type.  If all the components begin
at the same address, then the component is passed as if it were an
argument of the longest floating point type used by these components.
Otherwise, the argument is passed as if it were an argument of type
\code{__float128}.\footnote{In this case, there will be no padding
  bits, because this case can only occur if there is a value of type
  \code{float} in the second word of the doubleword.}

Otherwise, the doubleword is passed as if it were a single integer
argument, using the smallest type sufficient to contain the argument.
Any bytes not used by the value passed have undefined contents.

If the structure has more than 8 bytes, then the process is repeated
for the second doubleword.

\begin{figure}
\Hrule
  \caption{Generic Register Usage}
  \label{fig-reg-usage}
  \begin{center}
    \begin{tabular}{l|p{8cm}|l}
      \noalign{\smallskip}
      \multicolumn{1}{c}{} &
      \multicolumn{1}{c}{}&
      \multicolumn{1}{l}{\bf Preserved across} \\
      \multicolumn{1}{c}{\bf Register} &
      \multicolumn{1}{c}{\bf Usage}&
      \multicolumn{1}{l}{\bf function calls} \\
      \hline
      \noalign{\smallskip}
\RAX & temporary register; with variable arguments passes
information about the number of SSE registers used; 1$^{\rm st}$
return register & No \\
\RBX & callee-saved register; optionally used as base pointer & Yes \\
\RCX & used to pass 4$^{\rm th}$ integer argument to functions & No \\
\RDX & used to pass 3$^{\rm rd}$ argument to functions ; 2$^{\rm nd}$ return register & No \\
\RSP & stack pointer & Yes. \\
\RBP & callee-saved register & Yes \\
\RSI & used to pass 2$^{\rm nd}$  argument to functions & No \\
\RDI & used to pass 1$^{\rm st}$  argument to functions & No \\
\reg{r8} & used to pass 5$^{\rm th}$  argument to functions & No \\
\reg{r9} & used to pass 6$^{\rm th}$  argument to functions & No \\
\reg{r10} & temporary register, used for passing a function's static
chain pointer & No \\
\reg{r11} & temporary register & No\\
\reg{r12} & callee-saved register & Yes \\
\reg{r13} & callee-saved register & Yes \\
\reg{r14} & callee-saved register & Yes \\
\reg{r15} & callee-saved register & Yes \\
\reg{xmm0}--\reg{xmm1} & used to pass and return floating point
arguments & No\\
\reg{xmm2}--\reg{xmm15} & used to pass floating point arguments & No\\
\reg{mmx0}--\reg{mmx1},&&\\
\reg{st0}--\reg{st1} & temporary registers; used to return MMX arguments & No \\
\reg{mmx2}--\reg{mmx8},&&\\
\reg{st2}--\reg{st8} & temporary registers & No \\
    \end{tabular}

  \end{center}
\Hrule
\end{figure}

As an example of the register passing conventions, consider the
declarations and the function call shown in
Figure \ref{fig_passing_example}.  The corresponding register
allocation is given in Figure \ref{fig_allocation_example}.

\begin{figure}[H]
\Hrule
\caption{Parameter Passing Example}
\label{fig_passing_example}
\begin{center}
\code{
\begin{tabular}{|l|}
\cline{1-1}
typedef struct \{ \\
\ \ int a, b;\\
\ \ double d;\\
\} structparm;\\
structparm s;\\
int e, f, g, h, i, j, k;\\
long double ld;\\
double m, n;\\
\\
extern void func (int e, int f,\\
\phantom{extern void func (}structparm s, int g, int h,\\
\phantom{extern void func (}long double ld, double m,\\
\phantom{extern void func (}double n, int i, int j, int k);\\
);\\
\\
func (e, f, s, g, h, ld, l, m, n, i, j, k);\\
\cline{1-1}
\end{tabular}
}
\end{center}
\Hrule
\end{figure}

\begin{figure}[H]
\Hrule
\caption{Register Allocation Example}
\label{fig_allocation_example}
\begin{center}
\begin{tabular}{ll|ll|ll}
\multicolumn{2}{c}{General Purpose Registers} & 
\multicolumn{2}{c}{Floating Point Registers} & 
\multicolumn{2}{c}{Stack Frame Offset}\\
\hline
\RDI: &\code{e} & \reg{xmm0}: &\code{s.d} &\code{8:}& \code{j} \\
\RSI: &\code{f} & \reg{xmm1}: &\code{ld}& \code{12:}& \code{k} \\
\RDX: &\code{s.a,s.b} & \reg{xmm2}: &\code{m}&& \\
\RCX: &\code{g} & \reg{xmm3}: &\code{n}& & \\
\reg{r8}:&\code{h} & && & \\
\reg{r9}:&\code{i} & && & \\
\end{tabular}

\end{center}
\Hrule
\end{figure}


\subsection{Functions Returning Scalars or No Value}

If a function returns a scalar of type \code{__m64}, the value is
returned in \reg{mm0}.  If the function returns a scalar of some other
type, the value is returned in a register or registers.  The register
or registers chosen are the same as those that would be selected for a
value of the same type to be passed to a function taking only one
argument of that same type, except that the list for integral or
pointer type scalars consists of \RAX and \RDX.

\subsection{Functions Returning Structures or Unions}

If a function returns a structure or union whose size is greater than
16 bytes, or, for C++, if the structure or union is a non-POD, then
the caller provides space for the return value and passes the address
of this storage in \RDI as if it were the first argument to the
function.  In effect, this address becomes a ``hidden'' first
argument.

In this case, the function also sets \RDI to the value of the original
address in the callee's area before it returns.  Thus when the caller
receives control again, the address of the returned object resides in
register \RDI and can be used to access the object.

If a function returns a structure or union whose size is less than or
equal to 16 bytes, and, for C++, the structure or union is a POD, then
the structure is returned in registers.  The registers chosen for a
given structure or union type are the same as those that would be
selected for a value of the same type to be passed to a function
taking only one argument of that same structure type, except that the
list for integral or pointer type scalars consists of \RAX and \RDX.
For returning, structures and unions are treated the same way as for
passing them.

\section{Operating System Interface}

\subsection{Exception Interface}

As the \xARCH manuals describe, the processor changes mode to handle
\emph{\textindex{exceptions},} which may be synchronous, 
floating-point/coprocessor or asynchronous. 
Synchronous and floating-point/coprocessor exceptions,
being caused by instruction execution, can be explicitly generated
by a process. This section, therefore, specifies those eception types
with defined behavior. The \xARCH architecture classifies exceptions as
\emph{faults}, \emph{traps}, and \emph{aborts}. See the \intelabi 
for more information about their differences.

\subsubsection{Hardware Exception Types}
The operating system defines the correspondence between hardware
exceptions and the signals specified by \codeindex{signal}(BA\_OS)
as shown in table \ref{tab-hw-exceptions}. Contrary to the i386 
architecture, the \xARCH does not define any instructions that 
generate a bounds check fault in long mode.

\begin{table}
\Hrule
  \caption{Hardware Exceptions and Signals}
  \label{tab-hw-exceptions}
  \begin{center}
    \begin{tabular}[t]{c|l|l}
      \multicolumn{1}{c}{Number} & \multicolumn{1}{c}{Exception name}
         & \multicolumn{1}{c}{Signal}\\
      \hline
      \texttt{0} & \texttt{divide error fault} & \texttt{SIGFPE} \\
      \texttt{1} & \texttt{single step trap/fault} & \texttt{SIGTRAP} \\
      \texttt{2} & \texttt{nonmaskable interrupt} & \texttt{none} \\
      \texttt{3} & \texttt{breakpoint trap} & \texttt{SIGTRAP} \\
      \texttt{4} & \texttt{overflow trap} & \texttt{SIGSEGV} \\
      \texttt{5} & \texttt{(reserved)} &\\
      \texttt{6} & \texttt{invalid opcode fault} & \texttt{SIGILL} \\
      \texttt{7} & \texttt{no coprocessor fault} & \texttt{SIGFPE} \\
      \texttt{8} & \texttt{double fault abort} & \texttt{none} \\
      \texttt{9} & \texttt{coprocessor overrun abort} & \texttt{SIGSEGV} \\
      \texttt{10} & \texttt{invalid TSS fault} & \texttt{none} \\
      \texttt{11} & \texttt{segment no present fault} & \texttt{none} \\
      \texttt{12} & \texttt{stack exception fault} & \texttt{SIGSEGV} \\
      \texttt{13} & \texttt{general protection fault/abort}&\texttt{SIGSEGV} \\
      \texttt{14} & \texttt{page fault} & \texttt{SIGSEGV} \\
      \texttt{15} & \texttt{(reserved)} &\\
      \texttt{16} & \texttt{coprocessor error fault} & \texttt{SIGFPE} \\
      \texttt{other} & \texttt{(unspecified)} & \texttt{SIGILL}
    \end{tabular}
  \end{center}
\Hrule
\end{table}

\begin{table}
\Hrule
  \caption{Floating-point Exceptions}
  \begin{center}
    \begin{tabular}[t]{l|l}
      \multicolumn{1}{c}{Code} & \multicolumn{1}{c}{Reason} \\
      \hline
      \texttt{FPE\_FLTDIV} & \texttt{floating-point divide by zero} \\
      \texttt{FPE\_FLTOVF} & \texttt{floating-point overflow} \\
      \texttt{FPE\_FLTUND} & \texttt{floating-point underflow} \\
      \texttt{FPE\_FLTRES} & \texttt{floating-point inexact result} \\
      \texttt{FPE\_FLTINV} & \texttt{invalid floating-point operation} 
    \end{tabular}
  \end{center}
\Hrule
\end{table}

\subsection{Virtual Address Space}

Although the \xARCH architecture uses 64-bit pointers, implementations
are only required to handle 48-bit addresses.  Therefore, conforming
processes may only use addresses from \texttt{0x0000000000000000} to
\texttt{0x00007fffffffffff}\footnote{0x0000ffffffffffff is not a
  canoncial address and cannot be used.}.

No other changes required.

\subsection{Page Size}

Systems are permitted to use any page size between 4KB and 64KB,
inclusive.

No other changes required.

\subsection{Virtual Address Assignments}

Conceptually processes have the full address space available.
In practice, however, several factors limit the size of a process.
\begin{itemize}
  \item The system reserves a configuration dependent amount of virtual space.
  \item The system reserves a configuration dependent amount of space per
    process.
  \item
    A process whose size exceeds the system's available combined physical
    memory and secondary storage cannot run. Although some physical memory
    must be present to run any process, the system can execute processes that
    are bigger than physical memory, paging them to and from secondary storage.
    Nonetheless, both physical memory and secondary storage are
    shared resources. System load, which can vary from one program execution
    to the next, affects the available amount.
\end{itemize}

\begin{figure}[H]
\Hrule
  \caption{Virtual Address Configuration}
  \label{fig-address}
  \begin{center}
    \begin{tabular}{r|c|l}
      \noalign{\smallskip}  \cline{2-2}
      \verb|0xffffffffffffffff| & Reserved system area & End of memory\\
      & \dots & \\ \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0| & Process segments & Beginning of memory\\ \cline{2-2}
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

Although applications may control their memory assignments, the typical
arrangement appears in figure \ref{fig-cfg}.

\begin{figure}[H]
\Hrule
  \caption{Conventional Segment Arrangements}
  \label{fig-cfg}
  \begin{center}
    \begin{tabular}{r|c|l}
      \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & Stack segment & \\
      & \dots & \\ \cline{2-2}
      & \dots & \\
      & Data segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0x10000| & Text segments & \\ \cline{2-2}
      \verb|0| & Unmapped & \\ \cline{2-2}
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

\section{Coding Examples}

The following sections show only the difference to the i386 ABI.

\subsection{Architectural Constraints}

The \xARCH architecture usually does not allow to encode arbitrary
64bit constants as immediate operand of the instruction.  Most
instructions accept 32-bit immediates that are sign extended to the
64-bit ones.  Additionally the 32-bit operations with register
destinations implicitly perform zero extension making loads of 64-bit
immediates with upper half set to 0 even cheaper.

Additionally the branch instructions accept 32-bit immediate operands
that are sign extended and used to adjust instruction pointer.
Similarly an instruction pointer relative addressing mode exists for
data accesses with equivalent limitations.

In order to improve performance and reduce code size, it is desirable
to use different \textindex{code models} depending on the
requirements.

Code models define constraints for symbolic values that allow the
compiler to generate better code.  Basically code models differ in
addressing (absolute versus position independent), code size, data
size and address range.  We define only a small number of code models
that are of general interest:

\begin{description}
\item[\textindex{Small code model}]
  The virtual address of code executed is known at link time.
  Additionally all symbols are known to be located in the virtual
  addresses in the range from $0$ to $2^{31}-2^{10} - 1$.

  This allows the compiler to encode symbolic references with offsets
  in the range from $-2^{31}$ to $2^{10}$ directly in the sign
  extended immediate operands, with offsets in the range from $0$ to
  $2^{31}+2^{10}$ in the zero extended immediate operands and use
  instruction pointer relative addressing for the symbols wit offsets
  in the range $-2^{10}$ to $2^{10}$.

  This is the fastest code model and we expect it to be suitable for
  the vast majority of programs.

\item[\textindex{Kernel code model}]

  The kernel of an operating system is usually rather small but runs
  in the negative half of the address space.  So we define all symbols
  to be in the range from $2^{64}-2^{31}$ to $2^{64}-2^{10}$.

  This code model has advantages similar to those of the small model,
  but allows encoding of zero extended symbolic references only for
  offsets from $2^{31}$ to $2^{31}+2^{10}$. The range offsets for
  sign extended reference changes to $0$--$2^{31}+2^{10}$.

\item[\textindex{Medium code model}]

  The medium code model does not make any assumptions about the range
  of symbolic references to data sections. Size and address of the
  text section have the same limits as the small code model.

  This model requires the compiler to use \code{movabs} instructions
  to access static data and to load addresses into register, but keeps
  the advantages of the small code model for manipulation of addresses
  to the text section (specially needed for branches).

\item[\textindex{Large code model}]

  The large code model makes no assumptions about addresses and sizes
  of sections.

  The compiler is required to use the \code{movabs} instruction, as in
  the medium code model, even for dealing with addresses inside the
  text section.  Additionally, indirect branches are needed when
  branching to addresses whose offset from the current instruction
  pointer is unknown.

  It is possible to avoid the limitation for the text section by
  breaking up the program into multiple shared libraries, so we do not
  expect this model to be needed in the foreseeable future.

\item[\textindex{Small position independent code model} (\textindex{PIC})]

  Unlike the previous models, the virtual addresses of instructions
  and data are not known until dynamic link time.  So all addresses
  have to be relative to the instruction pointer.

  Additionally the maximum distance between a symbol and the end of an
  instruction is limited to $2^{31}-2^{10}-1$, allowing the compiler
  to use instruction pointer relative branches and addressing modes
  supported by the hardware for every symbol with an offset in the
  range $-2^{10}$ to $2^{10}$.

\item[\textindex{Medium position independent code model}
  (\textindex{PIC})]

  This model is like the previous model, but makes no assumptions
  about the distance of symbols to the data section.

  In the medium PIC model, the instruction pointer relative addressing
  can not be used directly for accessing static data, since the offset
  can exceed the limitations on the size of the displacement field in
  the instruction.  Instead an unwind sequence consisting of
  \code{movabs}, \code{lea} and \code{add} needs to be used.

\item[\textindex{Large position independent code model}
  (\textindex{PIC})]

  This model is like the previous model, but makes no assumptions
  about the distance of symbols.

  The large PIC model implies the same limitation as the medium
  PIC model regarding addressing of static data.  Additionally,
  references to the global offset table and to the procedure linkage
  table and branch destiniations need to be calculated in a similar
  way.

\end{description}

\subsection{Position-Independend Function Prologue}

\xARCH does not need any function prologue for calculating the global
offset table address since it does not have an explicit GOT pointer.

\subsection{Data Objects}

Not done yet.

\subsection{Function Calls}

\begin{figure}[H]
\Hrule
\caption{Position-Independent Direct Function Call}
\begin{center}
\begin{tabular}{|l|c|l|}
\cline{1-1}\cline{3-3}
extern void function ();  &&.globl function\\
function ();              &&call function@PLT\\
\cline{1-1}\cline{3-3}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\begin{figure}[H]
\Hrule
\caption{Position-Independent Indirect Function Call}
\begin{center}
\begin{tabular}{|l|c|l|}
\cline{1-1}\cline{3-3}
extern void (*ptr) ();    &&.globl ptr, name\\
extern void name ();      && \\
ptr = name;               &&movl ptr@GOTPCREL(\%rip), \%rax  \\
                          &&movl name@GOTPCREL(\%rip), \%rdx  \\
                          &&movl \%rdx, (\%rax)  \\
                          &&  \\
(*ptr)();                 &&movl ptr@GOTPCREL(\%rip), \%rax  \\
                          &&call *(\%rax)  \\
\cline{1-1}\cline{3-3}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\subsection{Variable Argument Lists}

Some otherwise portable C programs depend on the argument passing
scheme, implicitly assuming that 1) all arguments are passed on the
stack, and 2) arguments appear in increasing order on the stack.
Programs that make these assumptions never have been portable, but
they have worked on many implementations. However, they do not work on
the \xARCH architecture because some arguments are passed in
registers.  Portable C programs must use the header files
\code{<stdarg.h>} or \code{<varargs.h>} in order to handle variable
argument lists.

When a function taking variable-arguments is called, \reg{rax} must be
set to eight times the number of floating point parameters passed to
the function in SSE registers.

\subsubsection{The Register Save Area\index{register save area}}

The prologue of a function taking a variable argument list and known
to call the macro \code{va_start} is expected to save the argument
registers to the \emph{register save area}.  Each argument register
has a fixed offset in the register save area as defined in the figure
\ref{fig-reg-save}.

Only registers that might be used to pass arguments need to be saved.
Other registers are not accessed and can be used for other purposes.  If a
function is known to never accept arguments passed in
registers\footnote{This fact may be determined either by exploring
  types used by the \code{va_arg}
macro, or by the fact that the named
  arguments already are exhausted the argument registers entirely},
the register save area may be omitted entirely.

The prologue should use \RAX to avoid unnecessarily saving XMM
registers.  This is especially important for integer only programs to
prevent the initialization of the XMM unit.


\begin{figure}[H]
\Hrule
\caption{Register Save Area}
\label{fig-reg-save}
\begin{center}
\begin{tabular}{|l|r|}
\cline{1-2}
register&offset\\
\cline{1-2}
\RDI & $0$ \\
\RSI & $8$ \\
\RDX & $16$ \\
\RCX & $24$ \\
\reg{r8} & $32$ \\
\reg{r9} & $40$ \\
\reg{xmm0} & $48$ \\
\reg{xmm1} & $64$ \\
\dots &  \\
\reg{xmm15} & $288$ \\
\cline{1-2}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\subsubsection{The \codeindex{va_list} Type}

The \code{va_list} type is an array containing a single element of one
structure
containing the necessary information to implement the \code{va_arg} macro. The C
definition of \code{va_list} type is given in figure \ref{fig-va_list}.

\begin{figure}[H]
\Hrule
\caption{\code{va_list} Type Declaration}
\label{fig-va_list}
\begin{center}
\code{
\begin{tabular}{|l|}
\cline{1-1}
typedef struct \{\\
\ \ \ unsigned int gp_offset;\\
\ \ \ unsigned int fp_offset;\\
\ \ \ void *overflow_arg_area;\\
\ \ \ void *reg_save_area;\\
  \} va_list[1];\\
\cline{1-1}
\end{tabular}
}
\end{center}
\Hrule
\end{figure}


\subsubsection{The \codeindex{va_start} Macro}

The \code{va_start} macro initializes the structure as follows:

\begin{description}
\item [reg_save_area]
The element points to the start of the register save area.
\item [overflow_arg_area] This pointer is used to fetch arguments
  passed on the stack.  It is initialized with the address of the
  first argument passed on the stack, if any, and then always updated
  to point to the start of the next argument on the stack.
\item [gp_offset] The element holds the offset in bytes from
  \code{reg_save_area} to the place where the next available general
  purpose argument register is saved.  In case all argument registers
  have been exhausted, it is set to the value 48 ($6*8$).
\item [fp_offset]
The element holds the offset in bytes from \code{reg_save_area} to the
place where the next available floating point
argument register is saved.  In case all argument registers have been exhausted,
it is set to the value 304 ($6*8+16*16$).
\end{description}

\subsubsection{The \codeindex{va_arg} Macro}

The algorithm for the generic \code{va_arg(l, type)} implementation is
defined as follows:

\begin{enumerate}
\item
Determine whether \code{type} may be passed in the registers.  If not go to step \ref{stack}.
\item
Compute \code{num_gp} to hold the number of general purpose registers needed to pass \code{type}
and \code{num_fp} to hold the number of floating point registers needed.
\item
Verify whether arguments fit into registers.
In the case:
$$\code{l->gp_offset} > 48 - \code{num_gp} * 8$$ or $$\code{l->fp_offset} > 304 - \code{num_fp} * 16$$
go to step \ref{stack}.
\item
  Fetch \code{type} from \code{l->reg_save_area} with an offset of
  \code{l->gp_offset} and/or \code{l->fp_offset}.  This may require
  copying to a temporary location in case the parameter is passed in
  different register classes or requires an alignment greater than 8 for
  general purpose registers and 16 for XMM registers.
\item
Set:
$$\code{l->gp_offset} = \code{l->gp_offset} + \code{num_gp} * 8$$
$$\code{l->fp_offset} = \code{l->fp_offset} + \code{num_fp} * 16.$$
\item
Return the fetched \code{type}.
\item
\label{stack}
Align \code{l->overflow_arg_area} upwards to a 16 byte boundary if
alignment needed by \code{type} exceeds 8 byte boundary.
\item
Fetch \code{type} from \code{l->overflow_arg_area}.
\item
Set \code{l->overflow_arg_area} to:
$$\code{l->overflow_arg_area} + \code{sizeof} (\code{type})$$
\item
Align \code{l->overflow_arg_area} upwards to an 8 byte boundary.
\item
Return the fetched \code{type}.
\end{enumerate}

The \code{va_arg} macro is usually implemented as a compiler builtin and expanded in
simplified forms for each particular type.  Figure \reg{fig-va_arg} is a sample
implementation of the \code{va_arg} macro.
\begin{figure}[H]
\Hrule
\label{fig-va_arg}
\caption{Sample Implementation of \code{va_arg(l, int)}}
\begin{center}
\begin{tabular}{|llll|}
\cline{1-4}
&movl&\code{l->gp_offset}, \reg{eax}&\\
&cmpl&\$48, \reg{eax}&Is register available?\\
&jae&stack&If not, use stack\\
&leal&\$8(\RAX), \reg{edx}&Next available register\\
&addq&\code{l->reg_save_area}, \RAX&Address of saved register\\
&movl&\reg{edx}, \code{l->gp_offset}&Update \code{gp_offset}\\
&jmp&fetch&\\
stack:&movq&\code{l->overflow_arg_area}, \RAX&Address of stack slot\\
&leaq&8(\RAX), \RDX&Next available stack slot\\
&movq&\RDX,\code{l->overflow_arg_area}&Update\\
fetch:&movl&(\RAX), \reg{eax}&Load argument\\
\cline{1-4}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\section{DWARF Definition}

This section\footnote{This section is structured in a way similar to the psABI for PowerPC}
defines the Debug With Arbitrary Record Format (DWARF) debugging
format for the \xARCH processor family. The \xARCH ABI does not define
a debug format.  However, all systems that do implement DWARF shall use
the following definitions.

DWARF is a specification developed for symbolic, source-level debugging.
The debugging information format does not favor the design of any
compiler or debugger.  For more information on DWARF,
see \emph{DWARF Debugging Information Format},
revision: Version 2.0.0, July 27, 1993, UNIX International,
Program Languages SIG.

\subsection{DWARF Release Number}

The DWARF definition requires some machine-specific definitions.
The register number mapping needs to be specified for the \xARCH
registers. In addition, the DWARF Version 2 specification
requires processor-specific address class codes to be defined.

\subsection{DWARF Register Number Mapping}

Table \ref{tbl-reg-num-map} outlines the register number mapping
for the \xARCH processor family.%
\footnote{This document does not define mappings for priviledged registers.}%
\footnote{The table defines Return Address to have a register number, even
though the address is stored in $0($\RSP$)$ and not in a physical register.}

\begin{figure}
\caption{DWARF Register Number Mapping} \label{tbl-reg-num-map}
\begin{center}
\begin{tabular}{|l|r|l|}
\cline{1-3}
Register Name&Number&Abbreviation\\
\cline{1-3}
General Purpose Register RAX & 0 &\RAX\\
General Purpose Register RBX & 1 &\RBX\\
General Purpose Register RCX & 2 &\RCX\\
General Purpose Register RDX & 3 &\RDX\\
Frame Pointer Register   RBP & 4 &\RBP\\
General Purpose Register RSI & 5 &\RSI\\
General Purpose Register RDI & 6 &\RDI\\
Stack Pointer Register   RSP & 7 &\RSP\\
Extended Integer Registers 8-15 & 8-15 &\reg{r8}-\reg{r15}\\
Return Address RA
& 17&\\
SSE Registers 0-7              & 17-24 & \reg{xmm0}-\reg{xmm7} \\
Extended SSE Registers 8-15    & 25-32 & \reg{xmm8}-\reg{xmm15} \\
Floating Point Registers 0-7   & 33-40 & \reg{st0}-\reg{st7} \\
MMX Registers 0-7              & 41-48 & \reg{mm0}-\reg{mm7} \\
\cline{1-3}
\end{tabular}
\end{center}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "abi"
%%% End:
