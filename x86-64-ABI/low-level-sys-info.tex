
\chapter{Low Level System Information}

\section{Machine Interface}

\subsection{Processor Architecture}

The x86-64 architecture defines a new mode, referred to as 32/64-bit
mode. See x86-64 Specification details. All information in this
document is relevant only to 32/64-bit mode, unless stated otherwise.

\editornote{Is this correct?}

\subsection{Data Representation}

In accordance with x86 tradition and x86-64 register names the terms
byte, word, dword, qword and tword refer to the corresponding data
objects of 8, 16, 32, 64 and 128 bits in size.

\editornote{Is tword correct for 128 bits?  Elsewhere oword seems to
  be used instead}

\subsubsection{Fundamental Types}

The basic types are specified in Table \ref{tab-basic-types}.  The
\verb|__int128| and \verb|__mm64| types are optional.

\begin{table}
\caption{Basic Types}\label{tab-basic-types}
\begin{tabular}{lrllr}
\hline\noalign{\smallskip}
% multicolumn is used to shrink the table
&sizeof & type			&\multicolumn{2}{l}{C type\hfill alignment} \\
\noalign{\smallskip}\hline\noalign{\smallskip}
Integral:
&1	& signed byte		&        char, signed char		& 1 \\
&1	& unsigned byte		&        unsigned char, bool		& 1 \\
&2	& signed word		&        short, singed short		& 2 \\
&2	& unsigned word		&        unsigned short			& 2 \\
&4	& signed dword		&        int, signed int, wchar		& 4 \\
&4	& unsigned dword	&        unsigned int,	& 4 \\
&       &                       &        unsigned wchar & \\
&8	& signed qword		&        long, signed long, 	& 8 \\
&        &                       &       long long, 		&  \\
&        &                       &       signed long long		&  \\
&8	& unsigned qword	&                unsigned long,		&	8 \\
&        &                       &          unsigned long long		& \\
&16	& signed tword		&        \verb|__int128|, & 16 \\
&	& 		        &        signed \verb|__int128|	&  \\
&16	& unsigned oword	&                unsigned \verb|__int128|	&	16 \\
\hline
Packed:
&8	& MMX and 3DNOW		&	\verb|__mm64|				& 8 \\
&16	& SSE and SSE-2		&	\verb|__m128|				& 16 \\
\hline
Pointer:
&8	& unsigned qword	&		any type *		& 8 \\
\hline
Floating-
&4	& single-precision (IEEE) &	float				& 4 \\
point:&8	& double-precision (IEEE) &	double				& 8 \\
&16	& extended-precision (IEEE) & 	long double			& 16 \\
\hline
\end{tabular}
\end{table}

The IEEE extended-precision type uses a 15 bits exponent, 113 bits for
the mantissa (the high order significand bit is implicit) and an
exponent bias of 16383.  This type is optional and needs software
emulation.
\editornote{Is it really optional? - probably not (HH)}
\editornote{define optional 80-bit fp type?}

A null pointer (for all types) has value zero.

\subsubsection{Aggregates And Unions}

Structure members are "`naturally"' aligned.  Structures, arrays and
unions assume the alignment of the most strictly aligned component
(compare with Table \ref{tab-basic-types}). The size of aggregates is
a multiple of the alignment.

\subsubsection{Bit-Fields}

Bit-fields are non-negative values with the range from 1 to 64 bits
depending on the bit-field type. Bit ordering is equivalent to
Intel386 specs.

\editornote{This needs a bit (pun intended) more specificity.}


\section{Function Calling Sequence}
This section describes the standard function calling sequence, including stack frame
layout, register usage, parameter pasing and so on.

Only global functions must obey the calling conventions specified here.  For local
functions the different (and possibly more effective) methods may be used, as long as they
conform the requirements of the stack traceback algorithm.
\editornote{link to stack traceback here}

\subsection{Registers}
\label{subsec-registers}
The x86-64 architecture provides 16 general purpose registers, each 64 bits
wide. In addition the architecture provides 16 SSE registers, each 128 bits
wide and 8 x87 floating point registers, each 80 bits wide useable as 64bits
wide MMX/3dNOW! registers and several special purpose registers.

This subsection discusses usage of each register.  The registers called
\emph{global registers} ``belong'' to the calling function and called function
is required to preserve their values, while the \emph{temporary registers} may
be freely clobbered by the called function.
\editornote{The split to global/temporaries is still subject of change.}
\editornote{Define environment pointer register?}

\subsubsection {General Purpose Registers}
\begin{description}
\item [RAX]
Temporary register used to pass first qword of argument area and to return
first qword of the return value.
\item [RDX]
Temporary register used to pass second qword of argument area
and to return second qword of the return value.
\item [RCX] Temporary register used to pass third qword of argument area
and to return third qword of the return value.
\item [RBX] Temporary register used to pass fourth qword of argument area
and to return third qword of the return value.
\item [RBP] Global register optionally used as frame pointer.
\item [RSP] The stack pointer.
\item [RSI]
Temporary register used to pass fifth qword of argument area.
\item [RDI] 
Temporary register used to pass sixth qword of argument area.
\item [R8, R9] Temporary registers.
\item [R10 - R15] Global registers.
\end{description}


\subsubsection {SSE registers}
\begin{description}
\item [XMM0, XMM1] Temporary registers used to pass first two qwords of argument area and
to return first two qwords of the return value.
\item [XMM2 -- XMM6] Temporary registers used to pass qwords 2-6 of argument area
\item [XMM6 -- XMM13] Global registers
\item [XMM13 -- XMM15] Temporary registers
\end{description}


\subsubsection {MMX/3dNOW! and x87 registers}
Since the usage of SSE instruction set if prefered over the x87, the CPU is in
``MMX'' mode across the function calls. Every function that uses x87 register
stack is required to convert the registers properly using EMMS or FEMMS
instructions and thus x87 registers can not be used to hold values across the
function call.  To make usage of x87 easier, all MMX registers are temporaries,
so the FEMMS instruction may be used.
\begin{description}
\item [MM0, MM1] Temporary registers used to pass first two qwords of argument area and
to return first two qwords of the return value.
\item [MM2 -- MM6] Temporary registers used to pass qwords 2-6 of argument area
\item [MM7 -- MM8] Temporary registers
\item [st(0) -- st(8)] Temporary registers not available across function calls
\end{description}


\subsubsection {Special purpose registers}
All special purpose registers should be handled as global registers with
the exception of the direction flag in EFLAGS register.  The value of direction
flag must be clear at the entry of function.
\editornote{do we want to define values of fpu and SSE control words?}

\subsection{The Stack Frame}
In addition to registers, each function has frame on a run-time stack.  This
stack grows downward from high addresses, table \ref{tab-stack-frame} shows the
stack organization.

\begin{table}
\caption{the stack frame}
\label{tab-stack-frame}
\begin{center}
\begin{tabular}{l|l|l|l}
\hline\noalign{\smallskip}
Position & Contents & Frame & Size (bytes) \\
\noalign{\smallskip}\hline\noalign{\smallskip}
& Argument area qword 7+n & Previous & 8 \\
& $...$ & & \\
& Argument area qword 7 & & 8 \\
\hline
& Return address & Current & 8\\
RBP (optinally) & Previous RBP value & & 0 or 8\\
& Function frame & & unspecified\\
& Outgoing argument area & & unspecified\\
RSP & End of current frame & & 0\\
\hline
\end{tabular}
\end{center}
\end{table}

Function may expect the end of input argument area to be aligned to 16 byte
boundary - this means that $RSP - 8$ is always multiple of 8 at the entry
point. This alignment must be preserved to all called functions that does use
standard calling convention. The frames of functions with local calling
conventions may or may not obey this rule so algorithms for stack unwinding
can't rely on it.

At any point of program execution, the stack pointer (RSP) shall point to
the end of latest allocated stack frame.

\subsection{Classes}
The x86-64 CPU has three register classes available for parameter and return
value passing convention - the integer (general purpose) registers, SSE
registers and MMX registers.  All integral types and pointer belongs to the
class \emph{int}, all floating point values (including the 128bit type) and
type \verb|_m128| belongs to the class \emph{SSE} and finally the type
\verb|_mm64| to class \emph{MMX}.

Agregate and union types are split to qwords and each qword has assigned it's
own class. To assign class of qword \emph{X} first matching rule of the following
is used.
\begin{enumerate}
\item (Aggregates only) In case the qword \emph{X} contains upper half field of
\verb|__m128| type, the class is \emph{SSE2}

\item In case all fields of aggreagate (or all subtypes of union) crossing the
word \emph{X} have same class \emph{Y}, the class is \emph{Y}.

\item In case all fields of aggreagate (or all subtypes of union) crossing the
word \emph{X} have same class \emph{SSE} or \emph{SSE2}, the class is \emph{SSE}.

\item If nothing matches, use class \emph{Int}.
\end{enumerate}

Qword \emph{X} of aggregate gets assigned class \emph{Y} if and only
if all the fields crossing qword \emph{X} belongs to same class \emph{Y}.  When
no field crosses the given Qword, it's type is \emph{None}. When no class fits
the rules above, class \emph{Int} is used.  Exception is also

Similary qword \emph{X} of union gets assigned class \emph{Y} if and only if
each type in the union eighter do not cross \emph{X} or it's class for qword
\emph{X} is \emph{Y}.

\subsection{Parameter passing conventions}
\editornote{To be done}

\subsection{Return Values}

Scalars, complex numbers, aggregates and unions not exceeding 16 bytes or no
value are returned directly.  First one or two classes are assigned to given
value and then relevant registers are used as discussed in the subsection
\ref{subsec-registers} leaving rest of registers undefined.

The scalar values, aggregates and unions exceeding 8 bytes that belongs to
class \emph{SSE} are not split to two registers and register XMM0 is used to
return both qwords.  Complex values are always returned in two separate parts.
The first register contains real part, while second register imaginary. The
qword of type \emph{SSE2} is passed in upper half of XMM0 instead of the XMM1.

Complex numbers, aggregates and unions exceeding 16 bytes are stored to area
prepared by caller and passed to the function as ``hidden'' first parameter.
The conents of all the return registers is left undefined.  \editornote{i386
abi returns the pointer to the area to simplify caller.  Is that good idea?}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
