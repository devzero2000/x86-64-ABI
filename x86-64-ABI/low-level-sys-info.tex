\chapter{Low Level System Information}

\section{Machine Interface}

\subsection{Processor Architecture}

The \xARCH architecture defines a new mode, referred to as 32/64-bit
mode. See the \xARCH Specification details. All information in this
document is relevant only to 32/64-bit mode, unless stated otherwise.

\subsection{Data Representation}

Within this specification, the term \emph{halfword} refers to a 16-bit
object, the term \emph{word} refers to a 32-bit object, the term
\emph{doubleword} refers to a 64-bit object, and the term
\emph{quadword} refers to a 128-bit object.

\subsubsection{Fundamental Types}

Figure~\ref{basic-types} shows the correspondence between ISO C's
scalar types and the processor's.

\begin{figure}
  \caption{Scalar Types}\label{basic-types}
  \begin{tabular}{l|l|c|c|l}
    \hline\noalign{\smallskip}
     & &  & \multicolumn{1}{c|}{Alignment} & \multicolumn{1}{c|}{x86-64} \\
    \multicolumn{1}{c|}{Type} & \multicolumn{1}{c|}{C}
     &  \texttt{sizeof} & (bytes)   
     & \multicolumn{1}{c|}{Architecture}  \\
    \hline
    & \texttt{char}        & 1 & 1 & signed byte \\
    & \texttt{signed char} & & \\
    \cline{2-5}
    & \texttt{unsigned char} & 1 & 1 & unsigned byte \\
    \cline{2-5}
    & \texttt{short} & 2 & 2 & signed halfword \\
    & \texttt{signed short} & & \\
    \cline{2-5}
    & \texttt{unsigned short} & 2 & 2 & unsigned halfword \\
    \cline{2-5}
    & \texttt{int} & 4 & 4 & signed word \\
    Integral & \texttt{signed int} & & \\
    & \texttt{enum} & & \\
    \cline{2-5}
    & \texttt{unsigned int} & 4 & 4 & unsigned word \\
    \cline{2-5}
    & \texttt{long} & 8 & 8 & signed doubleword \\
    & \texttt{signed long} & & \\
    & \texttt{long long} & & \\
    & \texttt{signed long long} & & \\
    \cline{2-5}
    & \texttt{unsigned long} & 8 & 8 & unsigned doubleword \\
    & \texttt{unsigned long long} & 8 & 8 & unsigned doubleword \\
    \hline
    Pointer & \texttt{\textit{any-type} *} & 8 & 8 & unsigned doubleword \\
    & \texttt{\textit{any-type} (*)()} & & \\
    \hline
    Floating-& \texttt{float} & 4 & 4 & single (IEEE) \\
    point & \texttt{double} & 8 & 8 & double (IEEE) \\
    & \texttt{long double} & 16 & 16 & double extended (IEEE) \\
    & \texttt{__float80} & 12 & 4 & x87 extended\\
    \hline
    Packed & \texttt{__m64} & 8 & 8 & \MMX{} and \threednow \\
    & \texttt{__m128} & 16 & 16 & SSE and SSE-2 \\
  \end{tabular}
\end{figure}

The \code{long double} type uses a 15 bits exponent, 113 bits for the
mantissa (the high order significant bit is implicit) and an exponent
bias of 16383\footnote{This type needs software emulation.}  The
\code{__float80} type correspondends to the \code{long double} type of
the ia32 ABI.

\editornote{Should we define __int128?}

\editornote{Why do we use 16-byte long doubles instead of 12?}

A null pointer (for all types) has value zero.

\editornote{Should we explicitly allow misaligned accesses, as in the
  i386 ABI?}

\subsubsection{Aggregates And Unions}

An array uses the same alignment as its elements, except that an array
that requires at least 16 bytes always has alignment of at least 16
bytes.\footnote{This alignment requirement allows the use of SSE
  operations.}

\editornote{Do we really want to align a 17-byte array of characters
  on a 16-byte boundary?  This may happen often for a 16-byte
  fixed-size data-entry field.  Perhaps we should only do this for
  arrays of types other than \texttt{char}?}

No other changes required.

\subsubsection{Bit-Fields}

Amend the description of bit-field ranges as follows:

\begin{figure}[h]
  \begin{center}
    \leavevmode
    \begin{tabular}{l|l|l}
      \multicolumn{1}{c}{Bit-field Type} 
         & \multicolumn{1}{c}{Width $w$} 
         & \multicolumn{1}{c}{Range} \\
      \hline
      \texttt{signed long} & & $-2^{w - 1}$ to $2^{w-1}-1$ \\
      \texttt{long} & 1 to 64 & 0 to $2^{w}-1$ \\
      \texttt{unsigned long} & & 0 to $2^{w}-1$ \\
    \end{tabular}
  \end{center}
  \caption{Bit-Field Ranges}
\end{figure}

\editornote{Do we want to allow bitfields of type \texttt{__m64} or
  \texttt{__m128}?} 

No other changes required.

\section{Function Calling Sequence}

This section describes the standard function calling sequence,
including stack frame layout, register usage, parameter passing and so
on.

Only global functions must obey the calling conventions specified
here.  For local functions the different (and possibly more effective)
methods may be used, as long as they conform to the requirements of the
stack traceback algorithm.
\editornote{link to stack traceback here}

\editornote{Do we really want to require that stack traceback
  algorithms are supported?  That limits optimization.}

\subsection{Registers}
\label{subsec-registers}

The \xARCH architecture provides 16 general purpose registers, each 64
bits wide. In addition the architecture provides 16 SSE registers,
each 128 bits wide and 8 x87 floating point registers, each 80 bits
wide usable as 64 bits wide \MMX/\threednow registers and several special
purpose registers.

This subsection discusses usage of each register.  The registers called
\emph{global registers} ``belong'' to the calling function and the called function
is required to preserve their values, while the \emph{temporary registers} may
be freely clobbered by the called function.
\editornote{The split to global/temporaries is still subject of change.}
\editornote{Define environment pointer register?}

\subsubsection {General Purpose Registers}

\begin{description}
  \item [\RAX]
    Temporary register used to pass first integer argument and to return
    first qword of the return value.
  \item [\RDX]
    Temporary register used to pass second integer argument
    and to return second qword of the return value.
  \item [\RCX] Temporary register used to pass third integer argument.
  \item [\RBX] Temporary register used to pass fourth integer argument.
  \item [\RBP] Global register optionally used as frame pointer.
  \item [\RSP] The stack pointer.
  \item [\RSI]
    Temporary register used to pass fifth qword of argument area.
  \item [\RDI] 
    Temporary register used to pass sixth qword of argument area.
  \item [\reg{R8}, \reg{R9}] Temporary registers.
  \item [\reg{R10} -- \reg{R15}] Global registers.
\end{description}

\subsubsection {SSE registers}

\begin{description}
  \item [\reg{XMM0}, \reg{XMM1}] Temporary registers used to pass first two SSE arguments
    and to return first two qwords of the return value.
  \item [\reg{XMM2} -- \reg{XMM6}] Temporary registers used to pass 2nd--6th SSE arguments
  \item [\reg{XMM6} -- \reg{XMM13}] Global registers
  \item [\reg{XMM13} -- \reg{XMM15}] Temporary registers
\end{description}

\subsubsection {\MMX/\threednow and x87 registers}

Since the usage of SSE instruction set if prefered over the x87, the CPU is in
``\MMX'' mode across function calls. Every function that uses x87 register
stack is required to convert the registers properly using \op{emms} or \op{femms}
instructions and thus x87 registers cannot be used to hold values across a
function call.  To make usage of x87 easier, all \MMX{} registers are temporaries,
so the FEMMS instruction may be used.
\begin{description}
  \item [\reg{MM0}, \reg{MM1}] Temporary registers used to return first two qwords of the return value.
  \item [\reg{MM2} -- \reg{MM8}] Temporary registers.
  \item [\reg{st(0)} -- \reg{st(8)}] Temporary registers not available across function calls
\end{description}


\subsubsection {Special purpose registers}
All special purpose registers should be handled as global registers
with the exception of the direction flag in EFLAGS register.  The
value of the direction flag must be clear at the entry of a function.
\editornote{Do we want to define values of fpu and SSE control words?}

\subsection{The Stack Frame}
In addition to registers, each function has a frame on the run-time stack.  This
stack grows downwards from high addresses, figure \ref{fig-stack-frame} shows the
stack organization.


\begin{figure}
  \caption{Stack Frame}
  \label{fig-stack-frame}
  \begin{center}
    \begin{tabular}{r|cl|l}
      \noalign{\smallskip}
      \multicolumn{1}{l}{\bf Frame} &
      \multicolumn{1}{c}{\bf Contents} &
      \multicolumn{1}{l}{\bf Size} &
      \multicolumn{1}{l}{\bf Address} \\
      \noalign{\smallskip}  \cline{2-3}
      & incoming arguments qword $n$ & 8 bytes & $\RBP+16+8n$ \\
      & \dots & & \\
      Previous& incoming arguments qword $0$ & 8 bytes & $\RBP+16$ \\ \cline{1-4} 
      Current & return address & 8 bytes & $\RBP+8$\\ \cline{2-3}
      & previous \RBP{} value & 8 bytes & $\RBP$ \\ \cline{2-3}
      & local save area & unspecified & $\RBP-8$\\ 
      & \dots & & \\ \cline {2-3}
      & outgoing arguments qword $0$ & 8 bytes &\\
      & \dots & & \\
      & outgoing arguments qword $n$ & 8 bytes & $\RSP$ \\ \cline{2-3}
    \end{tabular}
  \end{center}
\end{figure}


Functions may expect the end of the input argument area to be aligned
to a 16 byte boundary --- this means that value $(\RSP - 8)$ is always a
multiple of $16$ at the entry point. This alignment must be preserved by
all called functions that use the standard calling convention. The
frames of functions with local calling conventions may or may not obey
this rule so algorithms for stack unwinding cannot rely on it.

At any point of program execution, the stack pointer, \RSP, shall point to
the end of  latest allocated stack frame.

The organization of the \emph{local save area} is implementation
specific. Usual practice is to save clobbered global registers in the
prologue at the beginning or end of save area and use rest for saving
local object and spilled variables.  Saving registers at the beginning
is harder to implement, since the offset from \RBP{} is not known
until after the register allocation, but overall results in shorter
and faster prologues and epilogues allowing to allocate and deallocate
the outgoing arguments area by the same instruction used to
(de)allocate the \emph{local save area}.

The usage of \RBP{} as base pointer may be avoided by using \RSP{} instead
to save two instructions in the prologue and epilogue and get global general
purpose register.  See details about stack traceback algorithm for conditions
when this optimization is allowed.

\subsection{Classes}

The \xARCH CPU has three register classes available for parameter and
return value passing convention --- the integer (general purpose)
registers, SSE registers and \MMX{} registers.  All integral types and
pointer belong to the class \emph{Int}, all floating point values
(including the 128bit type) and type \verb|_m128| belongs to the class
\emph{SSE} and finally the type \verb|_mm64| to class \emph{MMX}.

Aggregate and union types are split to qwords and each qword has
assigned its own class. To assign the class of qword \emph{X} the
first matching rule of the following is used.
\begin{enumerate}
  \item (Aggregates only) In case the qword \emph{X} contains upper half field of
    \verb|__m128| type, the class is \emph{SSE2}.

  \item In case all fields of aggregate (or all subtypes of union) crossing the
    word \emph{X} have the same class \emph{Y}, the class is \emph{Y}.

  \item In case all fields of aggregate (or all subtypes of union) crossing the
    word \emph{X} have the same class \emph{SSE} or \emph{SSE2}, the class
    is \emph{SSE}.

  \item If nothing matches, use class \emph{Int}.
\end{enumerate}

Qword \emph{X} of an aggregate gets assigned class \emph{Y} if and only
if all the fields crossing qword \emph{X} belongs to same class \emph{Y}.  If
no field crosses the given Qword, its type is \emph{None}. When no class fits
the rules above, class \emph{Int} is used.  Exception is also 
\editornote{Honza, something is missing here.}

Similarly qword \emph{X} of union gets assigned class \emph{Y} if and only if
each type in the union either does not cross \emph{X} or its class for qword
\emph{X} is \emph{Y}.

\subsection{Parameter Passing Conventions}

It is generally more efficient to pass arguments to called functions in
registers than to push them onto stack. Even with good support for memory
operands and \op{push} instruction, passing arguments in registers reduces
memory bandwidth as well as simplifies the cleanup after function call.  The
number of registers implemented in the processor architecture naturally limits
the number of arguments passed in this manner.

For \xARCH up to six general purpose registers and six SSE registers are used
for parameter passing.  If fewer (or no) arguments are passed, the unneeded registers
will contain undefined value at the entry of function.
\editornote{The number of registers is subject to change.}

\MMX{} registers are not used to pass \verb|__mm64| type, since \MMX{}
usage is depreached and doing so simplifies functions with variable
number of arguments.  Instead all arguments of type \verb|__mm64| as
well as arguments that do not fit into the available registers are
passed on the runtime stack.

The aggregates and unions shorter than 16~bytes are passed using registers,
while other using reference.  The caller is expected to make a copy of the object
so callee is allowed to freely modify the contents.  Caller may not copy the
object in case it is known to be unused after function call, it does have
proper alignment and no aliases. The aggregate or union, when passed in register
is represented equally as if it were passed at the stack slot.

The following algorithm is used to determine where data is passed for
C language.  For this purpose consider arguments as ordered from left
(first argument) to right (last arguments), although the order of
evaluation is unspecified. In this algorithm \verb|sr| contains first
available SSE register and \verb|gr| contains the next available
general purpose register and \verb|ap| is used as pointer to ``output
argument area'' on the stack.  As written the algorithm is not
directly applicable, since it fills the stack in opposite direction.
In reality a two pass algorithm is required.  The first pass computes
positions for output arguments and the second pass actually pushes the
arguments onto the stack and/or loads them into registers.


\subsubsection {Proposal 1: ``smart'' mapping of structures}

\begin{description}
  \item[Initialize:]
    Set $\verb|sr|=1$, $\verb|gr|=1$, $\verb|ap|=0$


  \item[Scan:]
    If there are no more arguments, go to ``terminate''. Otherwise select one of the
    following depending on the type of the next argument:
      \begin{description}
        \item[Simple integer argument:]
          Simple integer argument is one of the following:
          \begin{itemize}
            \item One of simple integer types, maximally 64~bits long.
            \item Pointer
            \item Aggregates and unions greater than 16~bytes should be treated as
              pointer to object, or copy of the objects where necessary to enforce
              call-by-value semantics.
            \item Aggregates and unions maximally 8~bytes long with class \emph{Int}
          \end{itemize}
        If $\verb|gr| >= 6$ go to other, otherwise pick \verb|gr|-th register from
        the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} and assign it to the current
        argument. Set \verb|gr| to $\verb|gr|+1$.


    \item[Simple SSE argument:]
      Simple SSE argument is one of the following:
      \begin{itemize}
        \item One of simple floating point types.
        \item Argument of type \verb|__m128|
        \item Aggregates and unions maximally 8~bytes long with class \emph{SSE}
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{SSE}
          and class \emph{SSE2} of the second qword.
      \end{itemize}
      If $\verb|sr| >= 6$ go to other, otherwise pick \verb|sr|-th register from
      the sequence:\reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
      and assign it to the current argument.
      Set \verb|gr| to $\verb|gr|+1$.

    \item[Double integer argument]
      Double integer argument is one of the following:
      \begin{itemize}
        \item Argument of type \verb|__int128|
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of both qwords \emph{Int}
      \end{itemize}
      If $\verb|gr| >= 5$ go to other, otherwise pick \verb|gr|-th register from
      the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} and assign it together with the
      next register to the current argument.

    \item[Double SSE argument]
      Double SSE argument is one of the following:
      \begin{itemize}
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of both qwords \emph{SSE}
      \end{itemize}
      If $\verb|sr| >= 5$ go to other, otherwise pick \verb|sr|-th register from
      the sequence: \reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
      and assign it together with the
      next register to the current argument.

    \item[Integer-SSE type argument]
      Integer-SSE type argument is one of the following:
      \begin{itemize}
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{Int}
          and second qword \emph{SSE}
      \end{itemize}
      If $\verb|sr| >= 6$ or $\verb|gr| >= 6$ go to other, otherwise pick \verb|gr|-th register from
      the sequence: \RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} 
      and assign it the second first qword of current argument and pick \verb|sr|-th register from
      the sequence: \reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
      and assign it the second qword of current argument.

    \item[SSE-Integer type argument]
      SSE-Integer type argument is one of the following:
      \begin{itemize}
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{SSE}
          and second qword \emph{Int}
      \end{itemize}
      If $\verb|sr| >= 6$ or $\verb|gr| >= 6$ go to other, otherwise pick \verb|sr|-th register from
      the sequence:
      \reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
      and assign it the second first qword of current argument and pick \verb|gr|-th register from
      the sequence:
      \RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} 
      and assign it the second qword of current argument.
   \end{description}
   Go to ``Scan''.

  \item[Other:]

    Arguments not handled otherwise are passed at stack frame. \RSP{} is the
    pointer to end of outgoing argument area and we do expect \RSP{} to be
    aligned to a 16~byte boundary and the outgoing area large enough to fit all
    the arguments (this means the value \verb|ap| bytes for the final value of
    \verb|ap| once algorithm terminates).  To compute the address of a given argument,
    round \verb|ap| to the nearest multiple of the operand's alignment in bytes
    (minimally to 8~bytes) and
    store assign location $\verb|ap|+\RSP$ to the argument and increase \verb|ap| by
    the size of argument in bytes.
    Go to ``Scan''.

  \item[Terminate:]
    Round \verb|ap| up to a multiple of 16. Terminate the algorithm.
\end{description}

As an example assume the function call as shown below:

\begin{verbatim}
int a,b,c,d,e;
float A,B;
double C,D;
long double E;
__mm64 mm;
struct small {long a; double b;} small;
struct large {int a,b,c,d,e,f;} small;
func (small, large, mm, a, b, c, d, e, A, B, C, D, E);
\end{verbatim}

The results of register allocation for parameter passing is shown in table \ref{tab-passing}.

\begin{table}
  \caption{Register Allocation For Parameter Passing.}\label{tab-passing}
  \begin{tabular}{rlrlrl}
    \hline\noalign{\smallskip}
    integer register & contents & SSE register & contents & stack slot & contents\\
    \noalign{\smallskip}\hline\noalign{\smallskip}
    \RAX & \verb|small.a| & \reg{XMM0} & \verb|small.b| & $\RSP$ & \verb|mm|\\
    \RDX & \verb|&large| & \reg{XMM1} & \verb|A| & $\RSP+8$ & \verb|e|\\
    \RCX & \verb|a| & \reg{XMM2} & \verb|B| &  & \\
    \RBX & \verb|b| & \reg{XMM3} & \verb|C| &  & \\
    \RSI & \verb|c| & \reg{XMM4} & \verb|D| &  & \\
    \RDI & \verb|d| & \reg{XMM5} & \verb|E| &  & \\
    \hline
  \end{tabular}
\end{table}

\subsubsection {Proposal 2: structures always mapped to the integers}

\begin{description}
  \item[Initialize:]
    Set $\verb|sr|=1$, $\verb|gr|=1$, $\verb|ap|=0$


  \item[Scan:]
    If there are no more arguments, go to ``terminate''. Otherwise select one of the
    following depending on the type of the next argument:
      \begin{description}
        \item[Simple integer argument:]
          Simple integer argument is one of the following:
          \begin{itemize}
            \item One of simple integer types, maximally 64~bits long.
            \item Pointer
            \item Aggregates and unions greater than 16~bytes should be treated as
              pointer to object, or copy of the objects where necessary to enforce
              call-by-value semantics.
            \item Aggregates and unions maximally 8~bytes long with class \emph{Int}
          \end{itemize}
        If $\verb|gr| >= 6$ go to other, otherwise pick \verb|gr|-th register from
        the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} and assign it to the current
        argument. Set \verb|gr| to $\verb|gr|+1$.


    \item[Simple SSE argument:]
      Simple SSE argument is one of the following:
      \begin{itemize}
        \item One of simple floating point types.
        \item Argument of type \verb|__m128|
        \item Aggregates and unions maximally 8~bytes long with class \emph{SSE}
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{SSE}
          and class \emph{SSE2} of the second qword.
      \end{itemize}
      If $\verb|sr| >= 6$ go to other, otherwise pick \verb|sr|-th register from
      the sequence:\reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
      and assign it to the current argument.
      Set \verb|gr| to $\verb|gr|+1$.

    \item[Double integer argument]
      Double integer argument is one of the following:
      \begin{itemize}
        \item Argument of type \verb|__int128|
        \item Aggregates and unions greater than 8~bytes and smaller than 17~bytes.
      \end{itemize}
      If $\verb|gr| >= 5$ go to other, otherwise pick \verb|gr|-th register from
      the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI{} and assign it together with the
      next register to the current argument.
   \end{description}
   Go to ``Scan''.

  \item[Other:]

    Arguments not handled otherwise are passed at stack frame. \RSP{} is the
    pointer to end of outgoing argument area and we do expect \RSP{} to be
    aligned to a 16~byte boundary and the outgoing area space large enough to fit all
    the arguments (this means the value \verb|ap| bytes for the final value of
    \verb|ap| once algorithm terminates).  To compute address of given argument,
    round \verb|ap| to the nearest multiple of the operand's alignment in bytes
    (minimally to 8~bytes) and
    store assign location $\verb|ap|+\RSP$ to the argument and increase \verb|ap| by
    the size of argument in bytes.
    Go to ``Scan''.

  \item[Terminate:]
    Round \verb|ap| up to a multiple of 16. Terminate the algorithm.
\end{description}

As an example assume the function call as shown below:

\begin{verbatim}
int a,b,c,d,e;
float A,B;
double C,D;
long double E;
__mm64 mm;
struct small {long a; double b;} small;
struct large {int a,b,c,d,e,f;} small;
func (small, large, mm, a, b, c, d, e, A, B, C, D, E);
\end{verbatim}

The results of register allocation for parameter passing is shown in table \ref{tab-passing}.

\begin{table}
  \caption{Register Allocation For Parameter Passing.}\label{tab-passing}
  \begin{tabular}{rlrlrl}
    \hline\noalign{\smallskip}
    integer register & contents & SSE register & contents & stack slot & contents\\
    \noalign{\smallskip}\hline\noalign{\smallskip}
    \RAX & \verb|small.a| & \reg{XMM0} & \verb|A| & $\RSP$ & \verb|mm|\\
    \RDX & \verb|small.b| & \reg{XMM1} & \verb|B| & $\RSP+8$ & \verb|e|\\
    \RCX & \verb|&large| & \reg{XMM2} & \verb|C| &$\RSP+16$& \verb|d| \\
    \RBX & \verb|a| & \reg{XMM3} & \verb|D| &  & \\
    \RSI & \verb|b| & \reg{XMM4} & \verb|E| &  & \\
    \RDI & \verb|c| & \reg{XMM5} & undefined &  & \\
    \hline
  \end{tabular}
\end{table}


\subsection{Variable Argument Lists}
Some otherwise portable C programs depend on the argument passing scheme,
implicitly assuming that 1) all arguments are passed on the stack, and 2)
arguments appear in increasing order on the stack. Programs that make these
assumptions never have been portable, but they have worked on many
implementations. However, they do not work on the \xARCH architecture because
some arguments are passed in registers. Portable C programs use the header
files \verb|stdarg.h| or \verb|varargs.h| to deal with variable argument lists
on x86-64 and other machines as well.

\editornote {Use flag to signalize SSE registers?}

\subsection{Return Values}

\subsubsection {Proposal 1: ``smart'' mapping of structures}
Scalars, complex numbers, aggregates and unions not exceeding 16 bytes or no
value are returned directly.  First one or two classes are assigned to given
value and then relevant registers are used as discussed in subsection
\ref{subsec-registers} leaving rest of registers undefined.

The scalar values are returned in single register. One of the
\RAX, \reg{XMM0} and \reg{MM0} are chosen according to their class.
\verb|__int128| is returned in \RDX:\RAX.

First oword of unions, aggregates and real part of complex values not exceeding
8 bytes is returned in same way as simple scalar registers.  Second oword
(when available) is returned in one of the following: \RAX, \reg{XMM0} and
\reg{MM1} depending on their class.  Class \emph{SSE-2} is returned in upper
half of register \reg{XMM0}.

Complex numbers, aggregates and unions exceeding 16 bytes are stored
in an area prepared by the caller and passed to the function as
``hidden'' first parameter.  The contents of all return registers is
left undefined.
\editornote{i386 abi returns the pointer to the area to simplify
  caller.  Is that good idea?}

\subsubsection {Proposal 2: integer-only mapping of structures}

The \verb|__mm64| type is returned using \reg{MM0}.  Complex numbers,
aggregates and unions exceeding 16 bytes are stored in an area prepared by the
caller and passed to the function as ``hidden'' first parameter.  The contents
of all return registers is left undefined.

Other values are returned as if they were passed as first argument to
the function.

\section{Operating System Interface}

\subsection{Virtual Address Space}

The \xARCH architecture provides 64~bits of virtual space, but
implementation is allowed to support less. The processes are allowed
to require only 48~bits of address space, as supported by the initial
implementation.  It is expected that the address space grows
monotonically in the future.

According the \emph{canonical address form} as defined by the \xARCH
architecture, every byte of virtual space is having two addresses unless the
implementation supports the full 64~bit address space.  The applications may not
depend on this behavior and address the data only using single address.

Memory management translates virtual address to physical address,
hiding physical addressing and letting a process run anywhere in the
system's real memory. Processes typically begin with three logical
segments called ``text'', ``data'' and ``stack''. An object file may
contain more segments (for example for debugger use), and a process
also creates additional segments for itself with system services.

\subsection{Page Size}

Memory is organized by pages, which are the system's smallest units of
memory allocation. The page size can vary from one system to another.
Processes may call \verb|sysconf|(\verb|BA_OS|) to determine the
current page size.  This ABI allows system to cluster memory to
logical power-of-two page sizes up to 65536 bytes.

\subsection{Virtual Address Assignments}
Conceptually processes have full (minimally) 48-bit address space available.
In practice, however, several factors limit the size of a process.
\begin{itemize}
  \item The system reserves configuration dependent amount of virtual space.
  \item The system reserves configuration dependent amount of space per
    process.
  \item
    A process whose size exceeds the system's available combined physical
    memory and secondary storage cannot run. Although some physical memory
    must be present to run any process, the system can execute processes that
    are bigger than physical memory, paging them to and from secondary storage.
    Nonetheless, both physical memory and secondary storage are
    shared resources. System load, which can vary from one program execution
    to the next, affects the available amounts.
\end{itemize}

\begin{figure}[H]
  \caption{Virtual Address Configuration}
  \label{fig-address}
  \begin{center}
    \begin{tabular}{r|c|l}
      \noalign{\smallskip}  \cline{2-2}
      \verb|0xffffffffffffffff| & Reserved system area & End of memory\\ 
      & \dots & \\ \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0| & Process segments & Beginning of memory\\ \cline{2-2}
    \end{tabular}
  \end{center}
\end{figure}

Figure \ref{fig-address} shows the virtual address configuration on the \xARCH
Architecture.  The segments with different properties are typically grouped in
different areas of the address space:

\begin{description}
  \item [Process segments]
    Processes loadable segments and stack may begin at 0. The exact addresses
    depend on the executable file format. Processes can control the amount
    of virtual memory allocated for stack space, as described below.
  \item [Dynamic segments]
    A process's dynamic segment resides below the reserved area.
  \item [Reserved] A reserved area resides at the top of virtual space.
\end{description}

As the figure shows, the system reserves the high end of virtual address space,
with a process's dynamic segments below that. Although the exact boundary
between the reserved area and a process depends on the system's configuration,
the reserved area shall not consume more than 1 GB of the address space.
Individual systems may reserve less space, increasing processes  virtual memory
range.

Although applications may control their memory assignments, the typical
arrangement appears in figure \ref{fig-cfg}.

\begin{figure}[H]
  \caption{Conventional Segment Arrangements}
  \label{fig-cfg}
  \begin{center}
    \begin{tabular}{r|c|l}
      \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & Stack segment & \\ 
      & \dots & \\ \cline{2-2}
      & \dots & \\
      & Data segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0x10000| & Text segments & \\ \cline{2-2}
      \verb|0| & Unmapped & \\ \cline{2-2}
    \end{tabular}
  \end{center}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
