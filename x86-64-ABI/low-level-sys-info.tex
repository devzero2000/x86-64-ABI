
\chapter{Low Level System Information}

\section{Machine Interface}

\subsection{Processor Architecture}

The x86-64 architecture defines a new mode, referred to as 32/64-bit
mode. See x86-64 Specification details. All information in this
document is relevant only to 32/64-bit mode, unless stated otherwise.

\editornote{Is this correct?}

\subsection{Data Representation}

In accordance with x86 tradition and x86-64 register names the terms
byte, word, dword, qword and tword refer to the corresponding data
objects of 8, 16, 32, 64 and 128 bits in size.

\editornote{Is tword correct for 128 bits?  Elsewhere oword seems to
  be used instead}

\subsubsection{Fundamental Types}

The basic types are specified in Table \ref{tab-basic-types}.  The
\verb|__int128| and \verb|__mm64| types are optional.

\begin{table}
\caption{Basic Types}\label{tab-basic-types}
\begin{tabular}{lrllr}
\hline\noalign{\smallskip}
% multicolumn is used to shrink the table
&sizeof & type			&\multicolumn{2}{l}{C type\hfill alignment} \\
\noalign{\smallskip}\hline\noalign{\smallskip}
Integral:
&1	& signed byte		&        char, signed char		& 1 \\
&1	& unsigned byte		&        unsigned char, bool		& 1 \\
&2	& signed word		&        short, singed short		& 2 \\
&2	& unsigned word		&        unsigned short			& 2 \\
&4	& signed dword		&        int, signed int, wchar		& 4 \\
&4	& unsigned dword	&        unsigned int,	& 4 \\
&       &                       &        unsigned wchar & \\
&8	& signed qword		&        long, signed long, 	& 8 \\
&        &                       &       long long, 		&  \\
&        &                       &       signed long long		&  \\
&8	& unsigned qword	&                unsigned long,		&	8 \\
&        &                       &          unsigned long long		& \\
&16	& signed tword		&        \verb|__int128|, & 16 \\
&	& 		        &        signed \verb|__int128|	&  \\
&16	& unsigned oword	&                unsigned \verb|__int128|	&	16 \\
\hline
Packed:
&8	& \MMX{} and 3DNOW		&	\verb|__mm64|				& 8 \\
&16	& SSE and SSE-2		&	\verb|__m128|				& 16 \\
\hline
Pointer:
&8	& unsigned qword	&		any type *		& 8 \\
\hline
Floating-
&4	& single-precision (IEEE) &	float				& 4 \\
point:&8	& double-precision (IEEE) &	double				& 8 \\
&16	& extended-precision (IEEE) & 	long double			& 16 \\
\hline
\end{tabular}
\end{table}

The IEEE extended-precision type uses a 15 bits exponent, 113 bits for
the mantissa (the high order significand bit is implicit) and an
exponent bias of 16383.  This type is optional and needs software
emulation.
\editornote{Is it really optional? - probably not (HH)}
\editornote{define optional 80-bit fp type?}

A null pointer (for all types) has value zero.

\subsubsection{Aggregates And Unions}

Structure members are ``naturally'' aligned.  Structures, arrays and
unions assume the alignment of the most strictly aligned component
(compare with Table \ref{tab-basic-types}). The size of aggregates is
a multiple of the alignment.

\subsubsection{Bit-Fields}

Bit-fields are non-negative values with the range from 1 to 64 bits
depending on the bit-field type. Bit ordering is equivalent to
Intel386 specs.

\editornote{This needs a bit (pun intended) more specificity.}


\section{Function Calling Sequence}

This section describes the standard function calling sequence,
including stack frame layout, register usage, parameter passing and so
on.

Only global functions must obey the calling conventions specified
here.  For local functions the different (and possibly more effective)
methods may be used, as long as they conform to the requirements of the
stack traceback algorithm.
\editornote{link to stack traceback here}

\subsection{Registers}
\label{subsec-registers}

The x86-64 architecture provides 16 general purpose registers, each 64
bits wide. In addition the architecture provides 16 SSE registers,
each 128 bits wide and 8 x87 floating point registers, each 80 bits
wide useable as 64 bits wide \MMX/3dNOW! registers and several special
purpose registers.

This subsection discusses usage of each register.  The registers called
\emph{global registers} ``belong'' to the calling function and the called function
is required to preserve their values, while the \emph{temporary registers} may
be freely clobbered by the called function.
\editornote{The split to global/temporaries is still subject of change.}
\editornote{Define environment pointer register?}

\subsubsection {General Purpose Registers}
\begin{description}
\item [\RAX]
Temporary register used to pass first integer argument and to return
first qword of the return value.
\item [\RDX]
Temporary register used to pass second integer argument
and to return second qword of the return value.
\item [\RCX] Temporary register used to pass third integer argument.
\item [\RBX] Temporary register used to pass fourth integer argument.
\item [\RBP] Global register optionally used as frame pointer.
\item [\RSP] The stack pointer.
\item [\RSI]
Temporary register used to pass fifth qword of argument area.
\item [\RDI] 
Temporary register used to pass sixth qword of argument area.
\item [\reg{R8}, \reg{R9}] Temporary registers.
\item [\reg{R10} -- \reg{R15}] Global registers.
\end{description}


\subsubsection {SSE registers}
\begin{description}
\item [\reg{XMM0}, \reg{XMM1}] Temporary registers used to pass first two SSE arguments
  and to return first two qwords of the return value.
\item [\reg{XMM2} -- \reg{XMM6}] Temporary registers used to pass 2nd--6th SSE arguments
\item [\reg{XMM6} -- \reg{XMM13}] Global registers
\item [\reg{XMM13} -- \reg{XMM15}] Temporary registers
\end{description}


\subsubsection {\MMX/3dNOW! and x87 registers}
Since the usage of SSE instruction set if prefered over the x87, the CPU is in
``\MMX'' mode across function calls. Every function that uses x87 register
stack is required to convert the registers properly using \op{emms} or \op{femms}
instructions and thus x87 registers cannot be used to hold values across a
function call.  To make usage of x87 easier, all \MMX registers are temporaries,
so the FEMMS instruction may be used.
\begin{description}
\item [\reg{MM0}, \reg{MM1}] Temporary registers used to return first two qwords of the return value.
\item [\reg{MM2} -- \reg{MM8}] Temporary registers.
\item [\reg{st(0)} -- \reg{st(8)}] Temporary registers not available across function calls
\end{description}


\subsubsection {Special purpose registers}
All special purpose registers should be handled as global registers with
the exception of the direction flag in EFLAGS register.  The value of direction
flag must be clear at the entry of function.
\editornote{Do we want to define values of fpu and SSE control words?}

\subsection{The Stack Frame}
In addition to registers, each function has a frame on the run-time stack.  This
stack grows downward from high addresses, figure \ref{fig-stack-frame} shows the
stack organization.


\begin{figure}
\caption{Stack Frame}
\label{fig-stack-frame}
\begin{center}
\begin{tabular}{r|cl|l}
\noalign{\smallskip}
\multicolumn{1}{l}{\bf Frame} &
\multicolumn{1}{c}{\bf Contents} &
\multicolumn{1}{l}{\bf Size} &
\multicolumn{1}{l}{\bf Address} \\
\noalign{\smallskip}  \cline{2-3}
& incoming arguments qword $n$ & 8 bytes & $\RBP+16+8n$ \\
& \dots & & \\
Previous& incoming arguments qword $0$ & 8 bytes & $\RBP+16$ \\ \cline{1-4} 
Current & return address & 8 bytes & $\RBP+8$\\ \cline{2-3}
& previous \RBP{} value & 8 bytes & $\RBP$ \\ \cline{2-3}
& local save area & unspecified & $\RBP-8$\\ 
& \dots & & \\ \cline {2-3}
& outgoing arguments qword $0$ & 8 bytes &\\
& \dots & & \\
& outgoing arguments qword $n$ & 8 bytes & $\RSP$ \\ \cline{2-3}
\end{tabular}
\end{center}
\end{figure}


Functions may expect the end of the input argument area to be aligned
to a 16 byte boundary --- this means that value $(\RSP - 8)$ is always a
multiple of $16$ at the entry point. This alignment must be preserved to
all called functions that use the standard calling convention. The
frames of functions with local calling conventions may or may not obey
this rule so algorithms for stack unwinding cannot rely on it.

At any point of program execution, the stack pointer, \RSP, shall point to
the end of latest allocated stack frame.

The organization of \emph{local save area} is implementation specific. Usual
practice is to save clobered global registers in the prologue at the beginning
or end of save area and use rest for saving local object and spilled variables.
Saving registers at the begining is harder to implement, since the offset
from \RBP{} is not known until after the register allocation, but overall results
in shorter and faster prologues and epilogues allowing to allocate and deallocate
the outgoing arguments are by same instruction used to (de)allocate the \emph{local
save area}.

The usage of \RBP{} as base pointer may be avoided by using \RSP{} instead
to save two instructions in the prologue and epilogue and get global general
purpose register.  See details about stack traceback algorithm for conditions
when this optimization is allowed.

\subsection{Classes}

The x86-64 CPU has three register classes available for parameter and
return value passing convention --- the integer (general purpose)
registers, SSE registers and \MMX registers.  All integral types and
pointer belong to the class \emph{Int}, all floating point values
(including the 128bit type) and type \verb|_m128| belongs to the class
\emph{SSE} and finally the type \verb|_mm64| to class \emph{MMX}.

Aggregate and union types are split to qwords and each qword has
assigned its own class. To assign the class of qword \emph{X} the
first matching rule of the following is used.
\begin{enumerate}
\item (Aggregates only) In case the qword \emph{X} contains upper half field of
\verb|__m128| type, the class is \emph{SSE2}.

\item In case all fields of aggregate (or all subtypes of union) crossing the
word \emph{X} have the same class \emph{Y}, the class is \emph{Y}.

\item In case all fields of aggregate (or all subtypes of union) crossing the
word \emph{X} have the same class \emph{SSE} or \emph{SSE2}, the class
is \emph{SSE}.

\item If nothing matches, use class \emph{Int}.
\end{enumerate}

Qword \emph{X} of an aggregate gets assigned class \emph{Y} if and only
if all the fields crossing qword \emph{X} belongs to same class \emph{Y}.  If
no field crosses the given Qword, its type is \emph{None}. When no class fits
the rules above, class \emph{Int} is used.  Exception is also 
% Honza, something is missing here.

Similary qword \emph{X} of union gets assigned class \emph{Y} if and only if
each type in the union either does not cross \emph{X} or its class for qword
\emph{X} is \emph{Y}.

\subsection{Parameter Passing Conventions}

It is generally more efficient to pass arguments to called functions in
registers than to push them onto stack. Even with good support for memory
operands and \op{push} instruction, passing arguments in registers reduces
memory bandwidth as well as simplifies the cleanup after function call.  The
number of registers implemented in the processor architecture naturally limits
the number of arguments passed in this manner.

For x86-64 up to six general purpose registers and six SSE registers are used
for parameter passing.  If fewer (or no) arguments are passed, the unneeded registers
will contain undefined value at the entry of function.
\editornote{The number of registers is subject to change.}

\MMX registers are not used to pass \verb|__mm64| type, since \MMX
usage is depreached and doing so simplifies functions with variable
number of arguments.  Instead all arguments of type \verb|__mm64| as
well as arguments that do not fit into the available registers are
passed on the runtime stack.

The aggregates and unions shorter than 16~bytes are passed using registers,
while other using reference.  The caller is expected to make a copy of the object
so callee is allowed to freely modify the contents.  Caller may not copy the
object in case it is known to be unused after function call, it does have
proper alignment and no aliases. The aggregate or union, when passed in register
is represented equally as if it were passed at the stack slot.

The following algorithm is used to determine where data is passed for
C language.  For this purpose consider arguments as ordered from left
(first argument) to right (last arguments), although the order of
evaluation is unspecified. In this algorithm \verb|sr| contains first
available SSE register and \verb|gr| contains the next available
general purpose register and \verb|ap| is used as pointer to ``output
argument area'' on the stack.  As written the algorithm is not
directly applicable, since it fills the stack in opposite direction.
In reality a two pass algorithm is required.  The first pass computes
positions for output arguments and the second pass actually pushes the
arguments onto the stack and/or loads them into registers.

\begin{description}
\item[Initialize:]
Set $\verb|sr|=1$, $\verb|gr|=1$, $\verb|ap|=0$


\item[Scan:]
If there are no more arguments, go to ``terminate''. Otherwise select one of the
following depending on the type of the next argument:
\begin{description}
\item[Simple integer argument:]
Simple integer argument is one of the following:
\begin{itemize}
\item One of simple integer types, maximally 64~bits long.
\item Pointer
\item Aggregates and unions greater than 16~bytes should be treated as
pointer to object, or copy of the objects where necessary to enforce
call-by-value semantics.
\item Aggregates and unions maximally 8~bytes long with class \emph{Int}
\end{itemize}
If $\verb|gr| >= 6$ go to other, otherwise pick \verb|gr|-th register from
the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI and assign it to the current
argument. Set \verb|gr| to $\verb|gr|+1$.


\item[Simple SSE argument:]
Simple SSE argument is one of the following:
\begin{itemize}
\item One of simple floating point types.
\item Argument of type \verb|__m128|
\item Aggregates and unions maximally 8~bytes long with class \emph{SSE}
\item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{SSE}
and class \emph{SSE2} of the second qword.
\end{itemize}
If $\verb|sr| >= 6$ go to other, otherwise pick \verb|sr|-th register from
the sequence:\reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
and assign it to the current argument.
Set \verb|gr| to $\verb|gr|+1$.

\item[Double integer argument]
Double integer argument is one of the following:
\begin{itemize}
\item Argument of type \verb|__int128|
\item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of both qwords \emph{Int}
\end{itemize}
If $\verb|gr| >= 5$ go to other, otherwise pick \verb|gr|-th register from
the sequence:\RAX, \RDX, \RCX, \RBX, \RSI, \RDI and assign it together with the
next register to the current argument.

\item[Double SSE argument]
Double SSE argument is one of the following:
\begin{itemize}
\item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of both qwords \emph{SSE}
\end{itemize}
If $\verb|sr| >= 5$ go to other, otherwise pick \verb|sr|-th register from
the sequence: \reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
and assign it together with the
next register to the current argument.

\item[Integer-SSE type argument]
Integer-SSE type argument is one of the following:
\begin{itemize}
\item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{Int}
and second qword \emph{SSE}
\end{itemize}
If $\verb|sr| >= 6$ or $\verb|gr| >= 6$ go to other, otherwise pick \verb|gr|-th register from
the sequence: \RAX, \RDX, \RCX, \RBX, \RSI, \RDI 
and assign it the second first qword of current argument and pick \verb|sr|-th register from
the sequence: \reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
and assign it the second qword of current argument.

\item[SSE-Integer type argument]
SSE-Integer type argument is one of the following:
\begin{itemize}
\item Aggregates and unions greater than 8~bytes and smaller than 17~bytes with class of first qword \emph{SSE}
and second qword \emph{Int}
\end{itemize}
If $\verb|sr| >= 6$ or $\verb|gr| >= 6$ go to other, otherwise pick \verb|sr|-th register from
the sequence:
\reg{XMM0}, \reg{XMM1}, \reg{XMM2}, \reg{XMM3}, \reg{XMM4}, \reg{XMM5}, \reg{XMM6}
and assign it the second first qword of current argument and pick \verb|gr|-th register from
the sequence:
\RAX, \RDX, \RCX, \RBX, \RSI, \RDI 
and assign it the second qword of current argument.
\end{description}
Go to ``Scan''.

\item[Other:]

Arguments not handled otherwise are passed at stack frame. \RSP{} is the
pointer to end of outgoing argument area and we do expect \RSP{} to be
aligned to a 16~byte boundary and the outgoing area space large enough to fit all
the arguments (this means the value \verb|ap| bytes for the final value of
\verb|ap| once algorithm terminates).  To compute address of given argument,
round \verb|ap| to the nearest multiple of the operand's alignment in bytes
(minimally to 8~bytes) and
store assign location $\verb|ap|+\RSP$ to the argument and increase \verb|ap| by
the size of argument in bytes.
Go to ``Scan''.

\item[Terminate:]
Round \verb|ap| up to a multiple of 16. Terminate the algorithm.
\end{description}

As an example assume the function call as shown below:

\begin{verbatim}
int a,b,c,d,e;
float A,B;
double C,D;
long double E;
__mm64 mm;
struct small {long a; double b;} small;
struct large {int a,b,c,d,e,f;} small;
func (small, large, mm, a, b, c, d, e, A, B, C, D, E);
\end{verbatim}

The results of register allocation for parameter passing is shown in table \ref{tab-passing}.

\begin{table}
\caption{Register Allocation For Parameter Passing.}\label{tab-passing}
\begin{tabular}{rlrlrl}
\hline\noalign{\smallskip}
integer register & contents & SSE register & contents & stack slot & contents\\
\noalign{\smallskip}\hline\noalign{\smallskip}
\RAX & \verb|small.a| & \reg{XMM0} & \verb|small.b| & $\RSP$ & \verb|mm|\\
\RDX & \verb|&large| & \reg{XMM1} & \verb|A| & $\RSP+8$ & \verb|e|\\
\RCX & \verb|a| & \reg{XMM2} & \verb|B| &  & \\
\RBX & \verb|b| & \reg{XMM3} & \verb|C| &  & \\
\RSI & \verb|c| & \reg{XMM4} & \verb|D| &  & \\
\RDI & \verb|d| & \reg{XMM5} & \verb|E| &  & \\
\hline
\end{tabular}
\end{table}


\subsection{Variable Argument Lists}
Some otherwise portable C programs depend on the argument passing scheme,
implicitly assuming that 1) all arguments are passed on the stack, and 2)
arguments appear in increasing order on the stack. Programs that make these
assumptions never have been portable, but they have worked on many
implementations. However, they do not work on the x86-64 Architecture because
some arguments are passed in registers. Portable C programs use the header
files \verb|stdarg.h| or \verb|varargs.h| to deal with variable argument lists
on x86-64 and other machines as well.

\editornote {Use flag to signalize SSE registers?}

\subsection{Return Values}

Scalars, complex numbers, aggregates and unions not exceeding 16 bytes or no
value are returned directly.  First one or two classes are assigned to given
value and then relevant registers are used as discussed in subsection
\ref{subsec-registers} leaving rest of registers undefined.

The scalar values, aggregates and unions exceeding 8 bytes that
belong to class \emph{SSE} are not split to two registers and
register XMM0 is used to return both qwords.  Complex values are
always returned in two separate parts.  The first register contains
the real part, while the second register the imaginary one. The qword
of type \emph{SSE2} is passed in the upper half of XMM0 instead of
XMM1.

Complex numbers, aggregates and unions exceeding 16 bytes are stored
in an area prepared by the caller and passed to the function as
``hidden'' first parameter.  The contents of all return registers is
left undefined.
\editornote{i386 abi returns the pointer to the area to simplify
  caller.  Is that good idea?}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
