\chapter{Low Level System Information}

\section{Machine Interface}

\subsection{Processor Architecture}

\subsection{Data Representation}

Within this specification, the term \emph{halfword} refers to a 16-bit
object, the term \emph{word} refers to a 32-bit object, the term
\emph{doubleword} refers to a 64-bit object, and the term
\emph{quadword} refers to a 128-bit object.

\subsubsection{Fundamental Types}

Figure~\ref{basic-types} shows the correspondence between ISO C's
scalar types and the processor's.

\begin{figure}
  \caption{Scalar Types}\label{basic-types}
{ % Use small here - the table is still too large
  % Has anybody an idea how to shrink the table so that it fits the page?
  \small
  \begin{tabular}{l|l|c|c|l}
    \hline\noalign{\smallskip}
     & &  & \multicolumn{1}{c|}{Alignment} & \multicolumn{1}{c|}{x86-64} \\
    \multicolumn{1}{c|}{Type} & \multicolumn{1}{c|}{C}
     &  \texttt{sizeof} & (bytes)   
     & \multicolumn{1}{c|}{Architecture}  \\
    \hline
    & \texttt{char}        & 1 & 1 & signed byte \\
    & \texttt{signed char} & & \\
    \cline{2-5}
    & \texttt{unsigned char} & 1 & 1 & unsigned byte \\
    \cline{2-5}
    & \texttt{short} & 2 & 2 & signed halfword \\
    & \texttt{signed short} & & \\
    \cline{2-5}
    & \texttt{unsigned short} & 2 & 2 & unsigned halfword \\
    \cline{2-5}
    & \texttt{int} & 4 & 4 & signed word \\
    Integral & \texttt{signed int} & & \\
    & \texttt{enum} & & \\
    \cline{2-5}
    & \texttt{unsigned int} & 4 & 4 & unsigned word \\
    \cline{2-5}
    & \texttt{long} & 8 & 8 & signed doubleword \\
    & \texttt{signed long} & & \\
    & \texttt{long long} & & \\
    & \texttt{signed long long} & & \\
    \cline{2-5}
    & \texttt{unsigned long} & 8 & 8 & unsigned doubleword \\
    & \texttt{unsigned long long} & 8 & 8 & unsigned doubleword \\
    \hline
    & \texttt{__int128} & 16 & 8 & signed quadword \\
    & \texttt{signed __int128} & 16 & 8 & signed quadword \\
    \hline
    & \texttt{unsigned __int128} & 16 & 8 & unsigned quadword \\
    \hline
    Pointer & \texttt{\textit{any-type} *} & 8 & 8 & unsigned doubleword \\
    & \texttt{\textit{any-type} (*)()} & & \\
    \hline
    Floating-& \texttt{float} & 4 & 4 & single (IEEE) \\
    point & \texttt{double} & 8 & 8 & double (IEEE) \\
    & \texttt{long double} & 16 & 16 & 80-bit extended (IEEE) \\
    & \texttt{__float128} & 16 & 16 & 128-bit extended (IEEE) \\
    \hline
    Packed & \texttt{__m64} & 8 & 8 & \MMX{} and \threednow \\
    & \texttt{__m128} & 16 & 16 & SSE and SSE-2 \\
  \end{tabular}
}
\end{figure}

The \codeindex{__float128} type uses a 15-bit exponent, a 113-bit
mantissa (the high order significant bit is implicit) and an exponent
bias of 16383.\footnote{Initial implementations of the \xARCH
  architecture are expected to support operations on the
  \texttt{__float128} type only via software emulation.}

The \code{long double} type uses a 15 bit exponent, a 64-bit mantissa
with an explicit high order significand bit and an exponent bias of
16383.\footnote{This type is the x87 double extented precision data
  type.}  Although a \code{long double} requires 16 bytes of storage,
only the first 10 bytes are significant.  The remaining six bytes are
tail padding, and the contents of these bytes are undefined.

The \code{__int128} type is stored in little-endian order in memory,
i.e., the 64 low-order bits are stored at a a lower address than the
64 high-order bits.

A null pointer (for all types) has value zero.

Like the Intel386 architecture, the \xARCH architecture does not
require all data access to be properly aligned.  Accessing misaligned
data will be slower than accessing properly aligned data, but
otherwise there is no difference.

\subsubsection{Aggregates and Unions}

An array uses the same alignment as its elements, except that an array
that requires at least 16 bytes, or a C99 variable-length array,
always has alignment of at least 16 bytes.\footnote{The alignment
  requirement allows the use of SSE instructions when operating on the
  array.  The compiler cannot in general calculate the size of a
  variable-length array, but it is expected that most VLAs will
  require at least 16 bytes, so it is logical to mandate that VLAs
  have at least a 16-byte alignment.}

No other changes required.

\subsubsection{Bit-Fields}

Amend the description of bit-field ranges as follows:

\begin{figure}[h]
\Hrule
  \caption{Bit-Field Ranges}
  \begin{center}
    \leavevmode
    \begin{tabular}{l|l|l}
      \multicolumn{1}{c}{Bit-field Type} 
         & \multicolumn{1}{c}{Width $w$} 
         & \multicolumn{1}{c}{Range} \\
      \hline
      \texttt{signed long} & & $-2^{w - 1}$ to $2^{w-1}-1$ \\
      \texttt{long} & 1 to 64 & 0 to $2^{w}-1$ \\
      \texttt{unsigned long} & & 0 to $2^{w}-1$ \\
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

The ABI does not permit bitfields having the type \texttt{__m64} or
\texttt{__m128}.  Programs using bitfields of these types are not
portable.

No other changes required.

\section{Function Calling Sequence}

This section describes the standard function calling sequence,
including stack frame layout, register usage, parameter passing and so
on.

The standard calling sequence requirements apply only to global
functions.  Local functions that are not reachable from other
compilation units may use different conventions.  Nevertheless, it is
recommended that all functions use the standard calling sequence when
possible.

\subsection{Registers and the Stack Frame}
\label{subsec-registers}

The \xARCH architecture provides 16 general purpose 64-bit registers.
In addition the architecture provides 16 SSE registers, each 128 bits
wide and 8 x87 floating point registers, each 80 bits wide.  Each of
the x87 floating point registers may be referred to in \MMX/\threednow
mode as a 64-bit register.  All of these registesr are global to all
procedures in a running program.

This subsection discusses usage of each register.  Registers \RBP,
registers \reg{r8} through \reg{r15} and registers \reg{xmm8} through
\reg{xmm15} ``belong'' to the calling function and the called function
is required to preserve their values.  In other words, a called
function must preserve these registers' values for its caller.
Remaining registers ``belong'' to the called function.\footnote{Note
  that in contrast to the \intelabi, \RBX, \RDI, and \RSI belong to
  the called function, not the caller.}  If a calling function wants
to preserve such a register value across a function call, it must save
the value in its local stack frame.

The CPU shall be in MMX mode upon entry to a function.  Therefore,
every function that uses the x87 register stack is required to issue
an \op{emms} or \op{femms} instruction before accessing the x87
register stack.\footnote{All \MMX{} registers are caller-saved, so
  callees that make use of the x87 register stack may use the fsater
  \op{femms} instruction.}

\subsection{The Stack Frame}
In addition to registers, each function has a frame on the run-time
stack.  This stack grows downwards from high addresses.  Figure
\ref{fig-stack-frame} shows the stack organization.

\begin{figure}
\Hrule
  \caption{Stack Frame}
  \label{fig-stack-frame}
  \begin{center}
    \begin{tabular}{r|c|l}
      \noalign{\smallskip}
      \multicolumn{1}{l}{\bf Position} &
      \multicolumn{1}{c}{\bf Contents} &
      \multicolumn{1}{l}{\bf Frame} \\
      \noalign{\smallskip}  \cline{2-3}
      \code{8n+16(\RBP)} & argument doubleword $n$ \\
      & \dots & Previous \\
      \code{16(\RBP)} & argument doubleword $0$ \\
      \cline{1-3} 
      \code{8(\RBP)} & return address \\ \cline{2-2}
      \code{0(\RBP)} & previous \RBP value \\ 
      \cline{2-2}
      \code{-8(\RBP)} & unspecified & Current \\ 
      & \dots & \\ 
      \code{0(\RSP)} & variable size
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

The end of the input argument area shall be aligned on a 16 byte
boundary.  In other words, the value $(\RSP - 8)$ is always a multiple
of $16$ when control is transferred to the function entry point.  The
stack pointer, \RSP, always point to the end of the latest allocated
stack frame.  \footnote{The conventional use of \RBP{} as a frame
  pointer for the stack frame may be avoided by using \RSP (the stack
  pointer) to index into the stack frame.  This technique saves two
  instructions in the prologue and epilogue and makes one additional
  general-purpose register (\RSP) available.}

\subsection{Parameter Passing}

After the argument values have been computed, they are placed in
registers, or pushed on the stack.  The arguments are processed in
right-to-left order.  Since the stack grows downwards, the rightmost
argument will have the highest address.\footnote{Right-to-left order
  makes the handling of functions that take a variable number of
  arguments simpler.  The location of the first argument can always be
  computed statically, based on the type of that argument.  It would
  be difficult to compute the address of the first argument if the
  arguments were pushed in left-to-right order.}

For each argument, the following method is used to determine the
location in which the argument is passed.  In all cases where a value
is pushed on the stack, the stack shall be left doubleword-aligned.
In all cases, the value pushed shall be located on a boundary whose
alignment is the maximum of 8 (doubleword alignment) and the alignment
of the type being pushed.  If the value does not consume the entire
doubleword, the contents of the unused storage located at higher
numbered addresses within the doubleword is undefined.

If the argument is a scalar type, other than \code{__m64} or
\code{__int128}, then it is placed in the next available register
suitable for its type.  In particular, arguments of integral or
pointer type are placed in the next available general purpose
register, taken in the order \RAX, \RDX, \RCX, \RBX, \RSI, \RDI,
\reg{r8}, and \reg{r9}.  Arguments of floating point type and of type
\code{__m128}, are placed in the next available SSE register, taken
in order from \reg{xmm0} to \reg{xmm7}.  If no registers are
available, the values are placed on the stack.

Scalar values of type \code{__int128} are handled as they consisted
of two separate 64-bit arguments of type \code{long}.  The 64
low-order bits are considered to be the first argument, and therefore
processed second.\footnote{Thus, if all 128 bits are placed on the
  stack, the low-order bits will be at a lower address, which allows
  the caller to access the value normally.}

Scalar values of type \code{__m64} are always placed on the stack.

Structure or union objects with more than 16 bytes, those that contain
scalar components of type \code{__m64}, or, in C++, non-POD structure
or union types,\footnote{A non-POD object cannot be returned in
  registers because such objects must have well defined addresses; the
  address at which an object is constructed (by the caller) and the
  address at which the object is destroyed (by the callee) must be the
  same.  Similar issues apply when returning a non-POD object from a
  function.} are always passed on the stack.  The stack is aligned as
required by the alignment of the structure or union type being passed.
Then, the structure value is copied onto the stack.

Structure or union objects that contain fewer than 16 bytes, do not
contain any scalar components of type \code{__m64}, and, in C++, are
PODs, are passed in registers, if registers are available.  If the
entire structure cannot be placed in registers as described below,
then the structure is passed on the stack, as above.  If the structure
contains a single scalar component, then it is passed as if it were a
single argument of that scalar type.  Otherwise, the first (or only,
if the structure has fewer than 8 bytes), doubleword of the sturcture
is passed first.  If the first doubleword consists of a single scalar
component of floating point type, the first doubleword is passed as if
it were an argument of that floating point type.  Otherwise, the
doubleword is passed as if it were a single integer argument, using
the smallest type sufficient to contain the argument.  Any bytes not
used by the value passed have undefined contents.  If the structure
has more than 8 bytes, then the process is repeated for the second
doubleword.

\subsection{Functions Returning Scalars or No Value}

If a function returns a scalar of type \code{__m64}, the value is
returned in \reg{mm0}.  If the function returns a scalar of some other
type, the value is returned in a register or registers.  The register
or registers chosen are the same as those that would be selected were
a value of the same type to be passed to a function taking only one
argument of that same structure type.

\subsection{Functions Returning Structures or Unions}

If a function returns a structure or union whose size is greater than
16 bytes, or, for C++, if the structure or union is a non-POD, then
the caller provides space for the return value and passes the address
of this address in \RAX as if it were the first argument to the
function.  In effect, this address becomes a ``hidden'' first
argument.

In this case, the function also sets \RAX to the value of the original
address in the calle's area before it returns.  Thus when the caller
receives control again, the address of the returned object resides in
register \RAX and can be used to access the object.
  
If a function returns a structure or union whose size is less than or
equal to 16 bytes, and, for C++, the structure or union is a POD, then
the structure is returned in registers.  The registers chosen for a
given structure or union type are the same as those that would be
selected were a value of the same type to be passed to a function
taking only one argument of that same structure type.

\section{Operating System Interface}

\subsection{Virtual Address Space}

Although the \xARCH architecture uses 64-bit pointers, implementations
are only required to handle 48-bit addresses.  Therefore, conforming
processes may only use addresses from \texttt{0x0000000000000000} to
\texttt{0x00007fffffffffff}\footnote{0x0000ffffffffffff is not a
  canoncial address and cannot be used.}.

No other changes required.

\subsection{Page Size}

Systems are permitted to use any page size between 4KB and 64KB,
inclusive.

No other changes required.

\subsection{Virtual Address Assignments}

Conceptually processes have the full address space available.
In practice, however, several factors limit the size of a process.
\begin{itemize}
  \item The system reserves a configuration dependent amount of virtual space.
  \item The system reserves a configuration dependent amount of space per
    process.
  \item
    A process whose size exceeds the system's available combined physical
    memory and secondary storage cannot run. Although some physical memory
    must be present to run any process, the system can execute processes that
    are bigger than physical memory, paging them to and from secondary storage.
    Nonetheless, both physical memory and secondary storage are
    shared resources. System load, which can vary from one program execution
    to the next, affects the available amount.
\end{itemize}

\begin{figure}[H]
\Hrule
  \caption{Virtual Address Configuration}
  \label{fig-address}
  \begin{center}
    \begin{tabular}{r|c|l}
      \noalign{\smallskip}  \cline{2-2}
      \verb|0xffffffffffffffff| & Reserved system area & End of memory\\ 
      & \dots & \\ \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0| & Process segments & Beginning of memory\\ \cline{2-2}
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

Although applications may control their memory assignments, the typical
arrangement appears in figure \ref{fig-cfg}.

\begin{figure}[H]
\Hrule
  \caption{Conventional Segment Arrangements}
  \label{fig-cfg}
  \begin{center}
    \begin{tabular}{r|c|l}
      \cline{2-2}
      & \dots & \\
      \verb|0x80000000000| & Dynamic segments & \\ \cline{2-2}
      & Stack segment & \\ 
      & \dots & \\ \cline{2-2}
      & \dots & \\
      & Data segments & \\ \cline{2-2}
      & \dots & \\
      \verb|0x10000| & Text segments & \\ \cline{2-2}
      \verb|0| & Unmapped & \\ \cline{2-2}
    \end{tabular}
  \end{center}
\Hrule
\end{figure}

\section{Coding Examples}

The following sections show only the difference to the i386 ABI.

\subsection{Position-Independend Function Prologue}

\xARCH does not need any function prologue for calculating the global
offset table address since it does not have an explicit GOT pointer.

\subsection{Data Objects}

Not done yet.

\subsection{Function Calls}

\begin{figure}[H]
\Hrule
\caption{Position-Independent Direct Function Call}
\begin{center}
\begin{tabular}{|l|c|l|}
\cline{1-1}\cline{3-3}
extern void function ();  &&.globl function\\
function ();              &&call function@PLT\\
\cline{1-1}\cline{3-3}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\begin{figure}[H]
\Hrule
\caption{Position-Independent Indirect Function Call}
\begin{center}
\begin{tabular}{|l|c|l|}
\cline{1-1}\cline{3-3}
extern void (*ptr) ();    &&.globl ptr, name\\
extern void name ();      && \\
ptr = name;               &&movl ptr@GOTPCREL(\%rip), \%rax  \\
                          &&movl name@GOTPCREL(\%rip), \%rdx  \\
                          &&movl \%rdx, (\%rax)  \\
                          &&  \\
(*ptr)();                 &&movl ptr@GOTPCREL(\%rip), \%rax  \\
                          &&call *(\%rax)  \\
\cline{1-1}\cline{3-3}
\end{tabular}
\end{center}
\Hrule
\end{figure}

\subsection{Variable Argument Lists}

Some otherwise portable C programs depend on the argument passing
scheme, implicitly assuming that 1) all arguments are passed on the
stack, and 2) arguments appear in increasing order on the stack.
Programs that make these assumptions never have been portable, but
they have worked on many implementations. However, they do not work on
the \xARCH architecture because some arguments are passed in
registers.  Portable C programs must use the header files
\code{<stdarg.h>} or \code{<varargs.h>} in order to handle variable
argument lists.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "abi"
%%% End: 
